<h1 id="Allocate-RT-时记得指定-filterMode-和-wrapMode">Allocate RT 时记得指定 filterMode 和 wrapMode<a class="headerlink" href="#Allocate-RT-时记得指定-filterMode-和-wrapMode" title="Permanent link">&para;</a></h1>
<!-- more -->

<p>最近在 URP 里遇到的坑：C# 里申请了一张 RT</p>
<div class="highlight"><pre><span></span><code><span class="n">RenderingUtils</span><span class="p">.</span><span class="n">ReAllocateIfNeeded</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">m_RT</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">desc</span><span class="p">);</span>
</code></pre></div>
<p>在 Shader 里用 Inline Sampler State 采样它，实现了某个效果</p>
<div class="highlight"><pre><span></span><code><span class="kt">float3</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
</code></pre></div>
<p>打包测试发现 OpenGL ES 上效果不对。</p>
<h2 id="原因">原因<a class="headerlink" href="#原因" title="Permanent link">&para;</a></h2>
<p>拿 RenderDoc 抓帧以后，发现在 DX11 上采样用的</p>
<table>
<thead>
<tr>
<th style="text-align: center;">UVW</th>
<th style="text-align: center;">Minification &amp; Magnification</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">ClampEdge</td>
<td style="text-align: center;">Linear</td>
</tr>
</tbody>
</table>
<p>这是正确的。但 OpenGL ES 上采样用的却是</p>
<table>
<thead>
<tr>
<th style="text-align: center;">UVW</th>
<th style="text-align: center;">Minification &amp; Magnification</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">Repeat</td>
<td style="text-align: center;">Point</td>
</tr>
</tbody>
</table>
<p>这组值刚好是 <a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/api/UnityEngine.Rendering.Universal.RenderingUtils.html#UnityEngine_Rendering_Universal_RenderingUtils_ReAllocateIfNeeded_UnityEngine_Rendering_RTHandle__UnityEngine_RenderTextureDescriptor__UnityEngine_FilterMode_UnityEngine_TextureWrapMode_System_Boolean_System_Int32_System_Single_System_String_"><code>RenderingUtils.ReAllocateIfNeeded</code></a> 方法中 <code>filterMode</code> 和 <code>wrapMode</code> 的默认值。</p>
<p>一查文档发现</p>
<blockquote>
<p><strong>Coupled textures and samplers</strong></p>
<p>Most of the time when sampling textures in shaders, the texture sampling state should come from <a href="https://docs.unity3d.com/Manual/class-TextureImporter.html">texture settings</a> – essentially, textures and samplers are coupled together. This is default behavior when using DX9-style shader syntax:</p>
<div class="highlight"><pre><span></span><code><span class="n">sampler2D</span><span class="w"> </span><span class="n">_MainTex</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="kt">half4</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">tex2D</span><span class="p">(</span><span class="n">_MainTex</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span>
</code></pre></div>
<p>Using sampler2D, sampler3D, samplerCUBE HLSL keywords declares both texture and sampler.</p>
<p>Most of the time this is what you want, and is <mark>the only supported option on older graphics APIs (OpenGL ES)</mark>. </p>
<p>...</p>
<p><strong>Separate textures and samplers</strong></p>
<p>...</p>
<p><strong>Inline sampler states</strong></p>
<p>...</p>
<p><mark>Just like separate texture + sampler syntax, inline sampler states are not supported on some platforms. Currently they are implemented on Direct3D 11/12 and Metal.</mark> <sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup></p>
</blockquote>
<p>我试下来 Vulkan 似乎也没问题，至少最后的效果没问题。</p>
<h2 id="结论">结论<a class="headerlink" href="#结论" title="Permanent link">&para;</a></h2>
<p>在 OpenGL ES 采样时用的是 RT 上的设置，<code>sampler_LinearClamp</code> 这种 Inline Sampler State 没用。</p>
<p>为了保证不同平台上效果一致，申请 RT 时加上 <code>filterMode</code> 和 <code>wrapMode</code>，和 Inline Sampler State 保持一致。或者干脆不用 Inline Sampler State，完全依靠 Texture Settings。</p>
<p>本文最前面的 C# 代码改成下面这样就能解决问题。</p>
<div class="highlight"><pre><span></span><code><span class="n">RenderingUtils</span><span class="p">.</span><span class="n">ReAllocateIfNeeded</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">m_RT</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="n">FilterMode</span><span class="p">.</span><span class="n">Bilinear</span><span class="p">,</span><span class="w"> </span><span class="n">TextureWrapMode</span><span class="p">.</span><span class="n">Clamp</span><span class="p">);</span>
</code></pre></div>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://docs.unity3d.com/Manual/SL-SamplerStates.html">Unity - Manual: Using sampler states</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div><hr />