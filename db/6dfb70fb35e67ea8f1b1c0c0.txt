<h1 id="复刻星穹铁道-20-梦境迷钟">复刻星穹铁道 2.0 梦境迷钟<a class="headerlink" href="#复刻星穹铁道-20-梦境迷钟" title="Permanent link">&para;</a></h1>
<!-- more -->

<p>简单复刻，重点在图的构建和寻路上。只做了一种视角，两个关卡。</p>
<div class="responsive-video-container">
    <iframe src="https://player.bilibili.com/player.html?aid=1250735475&bvid=BV1kJ4m1W76K&cid=1440682002&p=2&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
</div>

<p>GitHub: <a href="https://github.com/stalomeow/DreamTicker">https://github.com/stalomeow/DreamTicker</a>。</p>
<h2 id="渲染">渲染<a class="headerlink" href="#渲染" title="Permanent link">&para;</a></h2>
<p>重点：</p>
<ul>
<li>相机用正交投影，不要透视投影的近大远小的效果。</li>
<li>相机朝向必须和正方体的某个体对角线平行，否则做不到游戏里的效果。我用的相机欧拉角是 <span class="arithmatex">\((\arcsin\dfrac{1}{\sqrt{3}},-\dfrac{\pi}{4},0)\)</span>。</li>
<li>方块被分成镜子前、镜子内、镜子后三部分，提前放在场景里。</li>
</ul>
<p>渲染流程：</p>
<ol>
<li>镜子写入模板值 <code>1</code>（不输出颜色）</li>
<li>
<p>绘制方块</p>
<ul>
<li>镜子前的：模板测试 <code>Always</code></li>
<li>镜子内的：模板测试 <code>Equal 1</code></li>
<li>镜子外的：模板测试 <code>NotEqual 1</code></li>
</ul>
</li>
<li>
<p>绘制角色（深度测试 <code>Always</code>，避免被方块挡住）</p>
</li>
<li>绘制半透明的镜子</li>
</ol>
<h2 id="建图">建图<a class="headerlink" href="#建图" title="Permanent link">&para;</a></h2>
<p>这是一个视错觉游戏，在三维空间中不可能的路径，只要从玩家的视角看上去没问题就能行走，所以，很容易想到把方块变换到 viewport space 或者 screen space 再建图。</p>
<p>实际试下来，发现这两个 space 存在一些缺点：</p>
<ul>
<li>坐标依赖玩家的屏幕分辨率。不同分辨率下，算出来结果存在一些差异。</li>
<li>方块坐标和边长都不是整数。由于浮点数计算存在误差，计算相邻方块的坐标时经常算不准，没法在 <code>Dictionary&lt;Vector2, Block&gt;</code> 里访问到相应的方块。</li>
</ul>
<p>考虑到相机用的是正交投影，其矩阵为</p>
<div class="arithmatex">\[
\begin{bmatrix}
  \dfrac{2}{r-l} &amp;0 &amp;0 &amp;-\dfrac{r+l}{r-l} \\
  0 &amp;\dfrac{2}{t-b}  &amp;0  &amp;-\dfrac{t+b}{t-b} \\
  0 &amp;0  &amp;-\dfrac{2}{f-n}  &amp;-\dfrac{f+n}{f-n} \\
  0 &amp;0  &amp;0  &amp;1
\end{bmatrix}
\]</div>
<p>其中，<span class="arithmatex">\(r,l,t,b,f,n\)</span> 分别为视锥体的 right, left, top, bottom, far, near。Unity 的视锥体是对称的，即满足</p>
<div class="arithmatex">\[
\left\{\begin{matrix}
  r+l&amp;=0 \\
  t+b&amp;=0
\end{matrix}\right.
\]</div>
<p>所以，正交投影矩阵化简为</p>
<div class="arithmatex">\[
\begin{bmatrix}
  \dfrac{2}{r-l} &amp;0 &amp;0 &amp;0 \\
  0 &amp;\dfrac{2}{t-b}  &amp;0  &amp;0 \\
  0 &amp;0  &amp;-\dfrac{2}{f-n}  &amp;-\dfrac{f+n}{f-n} \\
  0 &amp;0  &amp;0  &amp;1
\end{bmatrix}
\]</div>
<p>对于 view space 的点 <span class="arithmatex">\((x,y,z)\)</span> 用上面的矩阵变换到 NDC 后是</p>
<div class="arithmatex">\[
(\dfrac{2}{r-l}x,\dfrac{2}{t-b}y,-\dfrac{2}{f-n}z-\dfrac{f+n}{f-n})
\]</div>
<p>发现 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 只是被缩放了常数倍。从 NDC 到 viewport space 或者 screen space 都是对 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 分别进行两种相同的线性变换。所以，从 view space 到 viewport space 或者 screen space 就是对 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span> 做了一些线性变换，完全可以省略。可以这样理解：一张照片在家里看和在学校里看没有差别，放大 10 倍和原大小整体上也没差别。</p>
<p>考虑到一个方块只有朝上的面才能行走，并且这个面从屏幕上看是一个平行四边形，不难构造出下面这个二维斜坐标系。任意选一个方块，将它朝上的那个面的中心作为原点。</p>
<p><img alt="坐标系" src="../../../obsidian-vault/attachments/unity_hsr_dream_ticker_explain.png" /></p>
<p>若以平行四边形格子的中心点表示该格，则 <span class="arithmatex">\((x,y)\)</span> 右边一格为 <span class="arithmatex">\((x+1,y)\)</span>，前面一格为 <span class="arithmatex">\((x,y+1)\)</span>，且 <span class="arithmatex">\(x,y\)</span> 均为整数。只要能把原来的三维地图转化成这个平行四边形网格，剩下的就很简单了。</p>
<h3 id="计算方块对应格子的坐标">计算方块对应格子的坐标<a class="headerlink" href="#计算方块对应格子的坐标" title="Permanent link">&para;</a></h3>
<p>将一个方块朝上的那个面的中心点称为 <code>UpperCenter</code>。</p>
<p>设某方块的 <code>UpperCenter</code> 在 view space 的坐标为 <span class="arithmatex">\((x,y,z)^T\)</span>，变换到斜坐标系后是 <span class="arithmatex">\((x',y')^T\)</span>。作为斜坐标系原点的 <code>UpperCenter</code> 在 view space 的坐标为 <span class="arithmatex">\((O_x,O_y,O_z)^T\)</span>。</p>
<p>将 world space 的两个<strong>方向</strong> <span class="arithmatex">\((1,0,0)^T\)</span> 和 <span class="arithmatex">\((0,0,1)^T\)</span> 变换到 view space，只取 x 和 y 分量，不要归一化，记为 <span class="arithmatex">\(\vec{a}\)</span> 和 <span class="arithmatex">\(\vec{b}\)</span>。这就是斜坐标系的两个基向量在 view space 的表示。</p>
<p>可求得</p>
<div class="arithmatex">\[
\begin{bmatrix}
 x'\\
 y'
\end{bmatrix} = \begin{bmatrix}
 \vec{a} &amp; \vec{b}
\end{bmatrix}^{-1} \left (\begin{bmatrix}
 x\\
 y
\end{bmatrix}-\begin{bmatrix}
 O_x\\
 O_y
\end{bmatrix} \right )
\]</div>
<h3 id="根据镜子做剔除">根据镜子做剔除<a class="headerlink" href="#根据镜子做剔除" title="Permanent link">&para;</a></h3>
<p>镜子前的方块不用管，全部保留即可。镜子内的方块只有玩家能看到的部分才算入网格地图中，镜子后的方块同理。镜子会把方块裁成不同形状，如下图。</p>
<p><img alt="镜子" src="../../../obsidian-vault/attachments/unity_hsr_dream_ticker_explain2.png" /></p>
<p>一个方块在当前视角下看是一个正六边形，根据对角线可以分成 6 个三角形。镜子只能横向移动，对移动后的坐标进行限制，可以保证这些三角形不被分割。</p>
<p>镜子在斜坐标系里是一个平行四边形，四条边的直线方程很容易算。上图中，红线的斜率是 <span class="arithmatex">\(0\)</span>，黄线的斜率是 <span class="arithmatex">\(-1\)</span>。只要知道镜子某个角的坐标，还有长和宽，就能算出四条直线方程。</p>
<p>如果一个三角形的重心在平行四边形内，这个三角形就是在镜子里，否则就在镜子外。</p>
<ul>
<li>对镜子内的方块，把不在镜子里的三角形删掉。</li>
<li>对镜子后的方块，把在镜子里的三角形删掉。</li>
</ul>
<h3 id="根据遮挡关系做剔除">根据遮挡关系做剔除<a class="headerlink" href="#根据遮挡关系做剔除" title="Permanent link">&para;</a></h3>
<p>方块之间存在遮挡关系，比如下面红色的面就被挡住了，它就不能算入网格地图中。</p>
<p><img alt="遮挡关系" src="../../../obsidian-vault/attachments/unity_hsr_dream_ticker_explain3.png" /></p>
<p>这部分的剔除还是以之前提到的三角形为单位。</p>
<p>这里其实有参考一点 Hi-Z 的思路。先把之前剔除下来的三角形的 view space z 都写入到一张 <code>zMap</code> 里，写入时只保留最大值。换句话说 <code>zMap</code> 存的是各点处离相机最近的三角形的 z 值。</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">SetZMap</span><span class="p">(</span><span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">Vector2Int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zMap</span><span class="p">,</span><span class="w"> </span><span class="n">Vector2Int</span><span class="w"> </span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">zMap</span><span class="p">.</span><span class="n">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">depth</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">zMap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">zMap</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Mathf</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>三角形的 z 值不需要很准确，够用就行。我直接把 <code>UpperCenter</code> 变换到 view space 后的 z 值作为该方块（投影的正六边形）里所有三角形的 z。</p>
<p>把每个格子拆分成下图中的 Lower Triangle 和 Upper Triangle。<code>zMap</code> 分成 <code>zMapLower</code> 和 <code>zMapUpper</code>，分别记录 Lower Triangle 和 Upper Triangle。</p>
<p><img alt="上下三角的定义" src="../../../obsidian-vault/attachments/unity_hsr_dream_ticker_explain4.png" /></p>
<p>正六边形则分成下面的六个三角形。</p>
<p><img alt="正六边形的分割" src="../../../obsidian-vault/attachments/unity_hsr_dream_ticker_explain5.png" /></p>
<p>遍历正六边形里的三角形，写入 z 值，然后再把被挡住的三角形删掉。</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">CullBlocksByViewSpaceZ</span><span class="p">(</span><span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">Vector2Int</span><span class="p">,</span><span class="w"> </span><span class="n">BlockGroup</span><span class="o">&gt;</span><span class="w"> </span><span class="n">bMap</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">Vector2Int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zMapLower</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">();</span>
<span class="w">    </span><span class="n">Dictionary</span><span class="o">&lt;</span><span class="n">Vector2Int</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zMapUpper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="p">();</span>

<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bMap</span><span class="p">.</span><span class="n">Values</span><span class="p">.</span><span class="n">SelectMany</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">LeftUpperTriangle</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">SetZMap</span><span class="p">(</span><span class="n">zMapLower</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedXY</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ViewSpaceUpperCenterZ</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">MiddleUpperTriangle</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">SetZMap</span><span class="p">(</span><span class="n">zMapUpper</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedXY</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ViewSpaceUpperCenterZ</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">RightUpperTriangle</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">SetZMap</span><span class="p">(</span><span class="n">zMapLower</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedXY</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vector2Int</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">),</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ViewSpaceUpperCenterZ</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">LeftLowerTriangle</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">SetZMap</span><span class="p">(</span><span class="n">zMapUpper</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedXY</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vector2Int</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ViewSpaceUpperCenterZ</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">MiddleLowerTriangle</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">SetZMap</span><span class="p">(</span><span class="n">zMapLower</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedXY</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vector2Int</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ViewSpaceUpperCenterZ</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">RightLowerTriangle</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">SetZMap</span><span class="p">(</span><span class="n">zMapUpper</span><span class="p">,</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedXY</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vector2Int</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="m">1</span><span class="p">),</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ViewSpaceUpperCenterZ</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">bMap</span><span class="p">.</span><span class="n">Values</span><span class="p">.</span><span class="n">SelectMany</span><span class="p">(</span><span class="n">g</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">g</span><span class="p">))</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">LeftUpperTriangle</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ViewSpaceUpperCenterZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">zMapLower</span><span class="p">[</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedXY</span><span class="p">])</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">LeftUpperTriangle</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">MiddleUpperTriangle</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">block</span><span class="p">.</span><span class="n">ViewSpaceUpperCenterZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">zMapUpper</span><span class="p">[</span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedXY</span><span class="p">])</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">block</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">MiddleUpperTriangle</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>最后删三角形时，只要考虑 Left Upper Triangle 和 Middle Upper Triangle，因为其他三角形与方块是否可以行走是无关的。</p>
<h3 id="构建无向图">构建无向图<a class="headerlink" href="#构建无向图" title="Permanent link">&para;</a></h3>
<p>判断一个平行四边形格子是否可以行走的方法：遍历此处所有的方块，看看能不能凑出 Left Upper Triangle 和 Middle Upper Triangle。</p>
<div class="highlight"><pre><span></span><code><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsWalkable</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">get</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">BlockProjectedShapes</span><span class="w"> </span><span class="n">shapes</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>

<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">_blocks</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">shapes</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">ProjectedShapes</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Walkable = LeftUpperTriangle | MiddleUpperTriangle</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">shapes</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">Walkable</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">BlockProjectedShapes</span><span class="p">.</span><span class="n">Walkable</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>剩下的很简单，和普通的二维网格一样。</p>
<h2 id="寻路">寻路<a class="headerlink" href="#寻路" title="Permanent link">&para;</a></h2>
<p>寻路一定要找最短路，否则角色可能会在地图上绕来绕去。这个 Demo 里用 bfs 就行。</p>
<h2 id="找到正确的路径提示">找到正确的路径提示<a class="headerlink" href="#找到正确的路径提示" title="Permanent link">&para;</a></h2>
<p>小人行走前，会有个带拖尾的特效提前把路径展示出来。拖尾用 <code>TrailRenderer</code> 实现。</p>
<p>这里有个坑。直接给 <code>TrailRenderer</code> 应用小人移动的逻辑的话，因为地图部分地方有高度差，从相机看过去拖尾会断掉。</p>
<p><img alt="拖尾的 artifact" src="../../../obsidian-vault/attachments/unity_hsr_dream_ticker_explain6.png" /></p>
<p>把移动时的 y 固定即可解决这个问题。</p>
<hr />
<p>设某个方块的 <code>UpperCenter</code> 在 view space 为 <span class="arithmatex">\((x, y, z)^T\)</span>。给定一个 world space 里的 <span class="arithmatex">\(y'\)</span>，需要找到 <span class="arithmatex">\(x'\)</span> 和 <span class="arithmatex">\(z'\)</span> 使得 <span class="arithmatex">\((x', y', z')^T\)</span> 变换到 view space 后 x 和 y 分量分别等于 <span class="arithmatex">\(x\)</span> 和 <span class="arithmatex">\(y\)</span>。</p>
<p>令 <code>worldToCameraMatrix</code> 等于</p>
<div class="arithmatex">\[
\begin{bmatrix}
 x_1 &amp;x_2 &amp;x_3 &amp;x_4 \\
 y_1 &amp;y_2 &amp;y_3 &amp;y_4 \\
 z_1 &amp;z_2 &amp;z_3 &amp;z_4 \\
 0 &amp;0 &amp;0 &amp;1 \\
\end{bmatrix}
\]</div>
<p>可以列出方程</p>
<div class="arithmatex">\[
\begin{bmatrix}
 x_1 &amp;x_2 &amp;x_3 &amp;x_4 \\
 y_1 &amp;y_2 &amp;y_3 &amp;y_4 \\
 z_1 &amp;z_2 &amp;z_3 &amp;z_4 \\
 0 &amp;0 &amp;0 &amp;1 \\
\end{bmatrix} \begin{bmatrix}
 x' \\
 y' \\
 z' \\
 1
\end{bmatrix} = \begin{bmatrix}
 x \\
 y \\
 t \\
 1
\end{bmatrix}
\]</div>
<p>有三个变量 <span class="arithmatex">\(x',z',t\)</span>。解得</p>
<div class="arithmatex">\[
\begin{bmatrix}
 x' \\
 z' \\
 t
\end{bmatrix} = \begin{bmatrix}
 x_1 &amp;x_3 &amp;0 \\
 y_1 &amp;y_3 &amp;0 \\
 z_1 &amp;z_3 &amp;-1 \\
\end{bmatrix}^{-1} \left ( \begin{bmatrix}
 x \\
 y \\
 0
\end{bmatrix} - y'\begin{bmatrix}
 x_2 \\
 y_2 \\
 z_2
\end{bmatrix} - \begin{bmatrix}
 x_4 \\
 y_4 \\
 z_4
\end{bmatrix} \right )
\]</div>
<p>把拖尾移动到 <span class="arithmatex">\((x', y', z')^T\)</span>（<span class="arithmatex">\(y'\)</span> 是可配置的定值），就能避免断裂。</p>
<h2 id="这套算法的问题">这套算法的问题<a class="headerlink" href="#这套算法的问题" title="Permanent link">&para;</a></h2>
<ol>
<li>视角必须锁死</li>
<li>处理不了纪念碑谷中的 T-Junction。参考下面视频：</li>
</ol>
<div class="responsive-video-container">
    <iframe width="560" height="315" src="https://www.youtube.com/embed/mCCC9hQm6MM?si=Df2R9I6B4kqWFM-C" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
</div>

<h2 id="更简单更泛用的方法">更简单更泛用的方法<a class="headerlink" href="#更简单更泛用的方法" title="Permanent link">&para;</a></h2>
<p>人工记录每种情况下的路径，程序根据不同情况选择路径，然后是正确答案就放个动画。</p>
<p>缺点是配置麻烦。</p><hr />