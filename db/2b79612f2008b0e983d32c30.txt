简简单单，一行分页。回头甚至能水个库？<hr /><p>分页是查询的一个基本要求之一。这部分代码大多重复，适合复用。下面是一种最佳实践：</p><p>这是一个传有分页数据的Gin Handler，它需要对数据库进行分页查询：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p propertyRepository)</span></span> GetPagedAndFiltered (limit, page <span class="type">int</span>)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我们定义一个<code>gorm</code>中间件去对数据库进行分页：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;gorm.io/gorm&quot;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> paginate <span class="keyword">struct</span> &#123;  </span><br><span class="line">limit <span class="type">int</span>  </span><br><span class="line">page <span class="type">int</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newPaginate</span><span class="params">(limit <span class="type">int</span>, page <span class="type">int</span>)</span></span> *paginate &#123;  </span><br><span class="line"><span class="keyword">return</span> &amp;paginate&#123;limit: limit,page: page&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *paginate)</span></span> paginatedResult(db *gorm.DB) *gorm.DB &#123;  </span><br><span class="line">offset := (p.page - <span class="number">1</span>) * p.limit  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> db.Offset(offset).  </span><br><span class="line">Limit(p.limit)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后，就可以在数据库中使用分页了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p propertyRepository)</span></span> GetPagedAndFiltered(limit, page <span class="type">int</span>) ([]Property, <span class="type">error</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> properties []Property  </span><br><span class="line">  </span><br><span class="line">err := p.db.Scopes(newPaginate(limit,page).paginatedResult).Find(&amp;properties).Error  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> properties, err  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我对上面的代码进行了进一步的集成。虽然损失了低耦合性质，但是只是在Gin使用的话体验拉满：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pagination <span class="keyword">struct</span> &#123;</span><br><span class="line">PageSize <span class="type">int</span></span><br><span class="line">PageNum  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetPagination Get pagination info</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPagination</span><span class="params">(c *gin.Context)</span></span> Pagination &#123;</span><br><span class="line"><span class="keyword">var</span> data Pagination</span><br><span class="line">pageSize, _ := strconv.Atoi(c.Query(<span class="string">&quot;pagesize&quot;</span>))</span><br><span class="line">pageNum, _ := strconv.Atoi(c.Query(<span class="string">&quot;pagenum&quot;</span>))</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> pageSize &gt;= <span class="number">100</span>:</span><br><span class="line">data.PageSize = <span class="number">100</span></span><br><span class="line"><span class="keyword">case</span> pageSize &lt;= <span class="number">0</span>:</span><br><span class="line">data.PageSize = <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> pageNum &lt;= <span class="number">0</span> &#123;</span><br><span class="line">data.PageNum = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pagination)</span></span> PaginatedResults(db *gorm.DB) *gorm.DB &#123;</span><br><span class="line">offset := (p.PageNum - <span class="number">1</span>) * p.PageSize</span><br><span class="line"><span class="keyword">return</span> db.Offset(offset).Limit(p.PageSize)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方法就是在Gin Handler中用<code>GetPagination</code>获取分页参数，然后在<code>model</code>的具体数据库实现操作中使用<code>db.Scopes(page.PaginatedResult).xxx</code>直接分页。</p><p>应该是一种最佳实践。</p>