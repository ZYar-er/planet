<h1 id="仿星铁渲染Bloom">仿星铁渲染：Bloom<a class="headerlink" href="#仿星铁渲染Bloom" title="Permanent link">&para;</a></h1>
<!-- more -->

<p>卡通渲染里 Bloom 还是挺重要的，它能对画面起到润色作用，比简单地后期调高饱和度要好看很多。</p>
<p><img alt="Bloom 效果图" src="../../../obsidian-vault/attachments/bloom-toon.png" /></p>
<h2 id="大致流程图">大致流程图<a class="headerlink" href="#大致流程图" title="Permanent link">&para;</a></h2>
<pre class="mermaid"><code>flowchart TD
    Original[原图] -- 预处理 --&gt; Mip0

    Mip0 -- 降采样 --&gt; Mip1
    Mip1 -- 降采样 --&gt; Mip2
    Mip2 -- 降采样 --&gt; Mip3
    Mip3 -- 降采样 --&gt; Mip4
    Mip4 -- 降采样 --&gt; Mip5

    Mip2 -- 高斯模糊 --&gt; Mip2Blur
    Mip3 -- 高斯模糊 --&gt; Mip3Blur
    Mip4 -- 高斯模糊 --&gt; Mip4Blur
    Mip5 -- 高斯模糊 --&gt; Mip5Blur

    Mip2Blur -- 合并 --&gt; BloomTexture
    Mip3Blur -- 合并 --&gt; BloomTexture
    Mip4Blur -- 合并 --&gt; BloomTexture
    Mip5Blur -- 合并 --&gt; BloomTexture

    BloomTexture -- 叠加 --&gt; Result[结果]
    Original -- 叠加 --&gt; Result</code></pre>
<h2 id="注意-HDR">注意 HDR<a class="headerlink" href="#注意-HDR" title="Permanent link">&para;</a></h2>
<p>参考 URP Bloom 的 <code>EncodeHDR</code> 和 <code>DecodeHDR</code>。Bloom 可能导致像素值超过 1，部分不支持 B10G11R11 RT 的设备要用 R8G8B8A8 RT 和 RGBM 编码。</p>
<h2 id="预处理">预处理<a class="headerlink" href="#预处理" title="Permanent link">&para;</a></h2>
<p>预处理就是把图像中较亮的部分提取出来。卡通渲染里一般直接减去一个阈值即可。</p>
<div class="highlight"><pre><span></span><code><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="mo">0</span><span class="p">,</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">_BloomThreshold</span><span class="p">.</span><span class="n">rrr</span><span class="p">);</span>
</code></pre></div>
<p>有需要的话，之后还可以给 <code>color</code> 乘上一个强度。</p>
<h2 id="降采样">降采样<a class="headerlink" href="#降采样" title="Permanent link">&para;</a></h2>
<p>降采样是为了之后用较小的卷积核模糊更大的范围，就是 Mipmap 的思路。一般用 bilinear 每次长和宽都减少一半。</p>
<h3 id="避免闪烁">避免闪烁<a class="headerlink" href="#避免闪烁" title="Permanent link">&para;</a></h3>
<p>常见的方法是 COD 用的 Karis Average：在第一次降采样时，给颜色乘上一个 <code>weight</code>，避免出现超级亮的像素。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">luma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">dot</span><span class="p">(</span><span class="n">color</span><span class="p">,</span><span class="w"> </span><span class="kt">float3</span><span class="p">(</span><span class="mf">0.2126</span><span class="p">,</span><span class="w"> </span><span class="mf">0.7152</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0722</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">luma</span><span class="p">);</span>
<span class="n">color</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
</code></pre></div>
<p>这个会降低颜色的饱和度，对卡通渲染来说比较难受，所以我没用。</p>
<p>其实，闪烁主要的原因是有单独几个超亮像素一会出现一会消失。可以在降采样时，和周围的像素做加权平均，把亮度压下去。这样如果一个像素周围很亮，那么它还是很亮，产生稳定的泛光。如果一个像素周围都是暗的，它的亮度也会被压下去，闪烁就减少了。这个方法对颜色的饱和度没有很大影响，至少肉眼看不出来。</p>
<p>在 Vertex Shader 里，计算四个 uv 坐标。坐标都取在像素之间，后面 Fragment Shader 里用 bilinear 采样。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float4</span><span class="w"> </span><span class="n">texelSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_BlitTexture_TexelSize</span><span class="p">;</span>
<span class="kt">float4</span><span class="w"> </span><span class="n">offset1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float4</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span>
<span class="kt">float4</span><span class="w"> </span><span class="n">offset2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float4</span><span class="p">(</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="w"> </span><span class="o">+</span><span class="mf">0.5</span><span class="p">);</span>
<span class="n">uv1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texelSize</span><span class="p">.</span><span class="n">xyxy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">offset1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">texcoord</span><span class="p">.</span><span class="n">xyxy</span><span class="p">;</span>
<span class="n">uv2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">texelSize</span><span class="p">.</span><span class="n">xyxy</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">offset2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">output</span><span class="p">.</span><span class="n">texcoord</span><span class="p">.</span><span class="n">xyxy</span><span class="p">;</span>
</code></pre></div>
<p>在 Fragment Shader 里，采样，然后计算平均值。</p>
<div class="highlight"><pre><span></span><code><span class="kt">half3</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv1</span><span class="p">.</span><span class="n">xy</span><span class="p">));</span>
<span class="kt">half3</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv1</span><span class="p">.</span><span class="n">zw</span><span class="p">));</span>
<span class="kt">half3</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv2</span><span class="p">.</span><span class="n">xy</span><span class="p">));</span>
<span class="kt">half3</span><span class="w"> </span><span class="n">c4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv2</span><span class="p">.</span><span class="n">zw</span><span class="p">));</span>
<span class="k">return</span><span class="w"> </span><span class="n">EncodeHDR</span><span class="p">(</span><span class="mf">0.25</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">c1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c4</span><span class="p">));</span>
</code></pre></div>
<h2 id="高斯模糊">高斯模糊<a class="headerlink" href="#高斯模糊" title="Permanent link">&para;</a></h2>
<p>设 <span class="arithmatex">\(G(x,y)\)</span> 是二维 <a href="../../../ecde-afda-cebi/">正态分布</a> 的概率密度函数，<span class="arithmatex">\(f(x,y)\)</span> 是坐标为 <span class="arithmatex">\((x,y)\)</span> 处像素的值，<span class="arithmatex">\(h(x,y)\)</span> 是该处模糊后的值。做一个半径为 <span class="arithmatex">\(r\)</span> 的高斯模糊，即</p>
<div class="arithmatex">\[
h(x,y)=\displaystyle\sum\limits_{i=-r}^{r}\displaystyle\sum\limits_{j=-r}^{r}f(x+i,y+j)G(i,j)
\]</div>
<p>假设图像的长和宽分别为 <span class="arithmatex">\(m,n\)</span>，这个采样数是 <span class="arithmatex">\(O(mnr^2)\)</span>，有点多。</p>
<h3 id="减少采样数">减少采样数<a class="headerlink" href="#减少采样数" title="Permanent link">&para;</a></h3>
<p>对于 <span class="arithmatex">\(G(x,y)\)</span>，<span class="arithmatex">\(X\)</span> 和 <span class="arithmatex">\(Y\)</span> 是相互独立的，相关系数 <span class="arithmatex">\(\rho=0\)</span>。一般情况下，我们给中间的像素较大的权值（<span class="arithmatex">\(\mu=0\)</span>），并且用对称的卷积核。所以</p>
<div class="arithmatex">\[
G(x,y)=\frac{1}{2\pi \sigma^2} \exp \left (-\dfrac{x^2 + y^2}{2 \sigma^2} \right )
\]</div>
<p>能求出 <span class="arithmatex">\(X\)</span> 和 <span class="arithmatex">\(Y\)</span> 均服从 <span class="arithmatex">\(N(0,\sigma^2)\)</span>，概率密度函数为</p>
<div class="arithmatex">\[
G(x)=\frac{1}{\sqrt{2\pi} \sigma} \exp \left (-\dfrac{x^2}{2 \sigma^2} \right )
\]</div>
<p>且有</p>
<div class="arithmatex">\[
G(x,y)=G(x)G(y)
\]</div>
<p>带入得</p>
<div class="arithmatex">\[
h(x,y)=\displaystyle\sum\limits_{i=-r}^{r} \left (\displaystyle\sum\limits_{j=-r}^{r}f(x+i,y+j)G(j) \right ) G(i)
\]</div>
<p>所以，可以先做纵向模糊</p>
<div class="arithmatex">\[
h_1(x,y)=\displaystyle\sum\limits_{j=-r}^{r} f(x,y+j) G(j)
\]</div>
<p>再做横向模糊</p>
<div class="arithmatex">\[
h(x,y)=\displaystyle\sum\limits_{i=-r}^{r} h_1(x+i,y) G(i)
\]</div>
<p>这样采样数就变成了 <span class="arithmatex">\(O(mnr)\)</span>，需要 2 个 pass。</p>
<h3 id="快速计算卷积核">快速计算卷积核<a class="headerlink" href="#快速计算卷积核" title="Permanent link">&para;</a></h3>
<p>根据 <a href="../../../ecbf-abci-cecj/#De-Moivre-Laplace-CLT">De Moivre-Laplace CLT</a>：若 <span class="arithmatex">\(X \sim B(n,p)\)</span>，当 <span class="arithmatex">\(n\)</span> 充分大时，可以近似认为 <span class="arithmatex">\(X \sim N(np, np(1-p))\)</span>。我们需要的是一个对称的卷积核，所以取 <span class="arithmatex">\(p=\dfrac{1}{2}\)</span>。这个其实就是一些文章中提到用杨辉三角近似的原理。</p>
<p><img alt="杨辉三角" src="../../../obsidian-vault/attachments/pascal-triangle.png" /></p>
<p>对于第 <span class="arithmatex">\(n\)</span> 行的一组数，它们除以 <span class="arithmatex">\(2^n\)</span> 后近似服从 <span class="arithmatex">\(N(\dfrac{n}{2},\dfrac{n}{4})\)</span>。</p>
<p>观察上面的图，每行最前面两个和最后面两个数都比较小，在计算时作用不大，可以去掉它们。<sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup> 如果要一个长度为 <span class="arithmatex">\(n\)</span> 的卷积核，则选择第 <span class="arithmatex">\(n+3\)</span> 行的中间 <span class="arithmatex">\(n\)</span> 个数存进数组，有</p>
<div class="arithmatex">\[
G[i]=\dfrac{1}{2^{n+3}-2(4+n)} \binom{n+3}{i+2}
\]</div>
<p>根据组合数的性质 <sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup></p>
<div class="arithmatex">\[
\binom{n}{k+1}=\dfrac{n-k}{k+1}\binom{n}{k}
\]</div>
<p>可以求出递推公式</p>
<div class="arithmatex">\[
G[i]=\dfrac{n-i+2}{i+2} G[i-1]
\]</div>
<p>它的初始值，我给出的是 <span class="arithmatex">\(G[0]\)</span> 前面一个值，不存进数组。</p>
<div class="arithmatex">\[
G[-1]=\dfrac{n+3}{2^{n+3}-2(4+n)}
\]</div>
<p>不放代码了，一个 for 循环就行了。还能根据卷积核的对称性优化一下，只需要算一半的数字就行。</p>
<h3 id="Shader-代码">Shader 代码<a class="headerlink" href="#Shader-代码" title="Permanent link">&para;</a></h3>
<p>需要 C# 代码传入的值：</p>
<ul>
<li><code>_BloomKernelSize</code>：卷积核的长度。</li>
<li><code>_BloomKernel</code>：卷积核数组。</li>
</ul>
<p>Shader 里用一个 for 循环采样周围像素。</p>
<ul>
<li>卷积核长度为偶数时，为了给中心的像素足够的权重，就都采样在两个像素之间了，<code>i - halfKernelSize</code> 为 <span class="arithmatex">\(-1.5,-0.5,0.5,1.5\)</span> 这样的值。</li>
<li>卷积核长度为奇数时，<code>i - halfKernelSize</code> 为 <span class="arithmatex">\(-1,0,1\)</span> 这样的值。</li>
</ul>
<p>纵向模糊：</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">texelSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">_BlitTexture_TexelSize</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">halfKernelSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">_BloomKernelSize</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span>
<span class="kt">float2</span><span class="w"> </span><span class="n">uv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnityStereoTransformScreenSpaceTex</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>

<span class="kt">half3</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">_BloomKernelSize</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float2</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float2</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">texelSize</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">halfKernelSize</span><span class="p">));</span>
<span class="w">    </span><span class="kt">half3</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">));</span>
<span class="w">    </span><span class="n">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">_BloomKernel</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="n">EncodeHDR</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
</code></pre></div>
<p>横向模糊类似。</p>
<p>要把多级 mip 都纵向横向模糊一遍。</p>
<h3 id="卷积核长度选择">卷积核长度选择<a class="headerlink" href="#卷积核长度选择" title="Permanent link">&para;</a></h3>
<p>根据 <a href="../../../ecde-afda-cebi/#3-sigma-规则">正态分布 &gt; 3 sigma 规则</a>，大致推测出高斯模糊的模糊范围和 <span class="arithmatex">\(\sigma\)</span> 正相关。因为长度为 <span class="arithmatex">\(n\)</span> 的卷积核取的是杨辉三角的第 <span class="arithmatex">\(n+3\)</span> 行，所以</p>
<div class="arithmatex">\[
\sigma \approx \dfrac{\sqrt{n+3}}{2}
\]</div>
<p>因此，模糊的范围和卷积核的长度正相关。</p>
<p>mip 的分辨率越小，模糊的范围（卷积核的长度）就应该越大，否则可能出现很多方块图样。</p>
<h3 id="处理多分辨率">处理多分辨率<a class="headerlink" href="#处理多分辨率" title="Permanent link">&para;</a></h3>
<p>同样的图案在不同分辨率下占有的像素数量不同。在卷积核大小不变的前提下，去模糊本文最上面花火的脸，低分辨率下能采样到脸外面的像素，但是高分辨率下就不一定能采样到了。所以多分辨率下模糊的结果可能不一致，最后泛光效果也不一样。具体来说，分辨率越高，向外泛出的光就越少。</p>
<p>我目前也没找到什么很好的解决方案，就强行把最后几个需要模糊的 mip 的分辨率都定死了。</p>
<p>一般游戏都是 16:9、16:10 这样的分辨率。取个比例差不多的较小的分辨率，比如 310x174，基本上没太大问题。要是屏幕比例差得太多，降采样时就会出现明显拉伸，Bloom 结果就会出现 artifact。</p>
<h3 id="图集优化">图集优化<a class="headerlink" href="#图集优化" title="Permanent link">&para;</a></h3>
<p>因为要对多级 mip 做模糊，会出现很多 RT switch，对性能有影响。可以把纵向模糊的结果都绘制到一张图集上。用 <a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetViewport.html"><code>CommandBuffer.SetViewport</code></a> 来限制绘制的区域。</p>
<p><img alt="图集" src="../../../obsidian-vault/attachments/bloom-atlas.png" /></p>
<p>然后再做横向模糊，绘制到另一张图集上。</p>
<h2 id="合并">合并<a class="headerlink" href="#合并" title="Permanent link">&para;</a></h2>
<p>需要 C# 代码传入的值：</p>
<ul>
<li><code>_BloomUVMinMax</code>：图集中每张图的 uv 范围。xy 是 uv 最小值，zw 是 uv 最大值。</li>
</ul>
<p>Shader 里直接把图集里所有图都采样一遍，然后叠加。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float2</span><span class="w"> </span><span class="n">uv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">UnityStereoTransformScreenSpaceTex</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">);</span>

<span class="kt">half3</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span>
<span class="n">UNITY_UNROLL</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_MIP_DOWN_BLUR_COUNT</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float2</span><span class="w"> </span><span class="n">atlasUV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">lerp</span><span class="p">(</span><span class="n">_BloomUVMinMax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">xy</span><span class="p">,</span><span class="w"> </span><span class="n">_BloomUVMinMax</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">zw</span><span class="p">,</span><span class="w"> </span><span class="n">uv</span><span class="p">);</span>
<span class="w">    </span><span class="n">color</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">DecodeHDR</span><span class="p">(</span><span class="n">SAMPLE_TEXTURE2D_X</span><span class="p">(</span><span class="n">_BlitTexture</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_LinearClamp</span><span class="p">,</span><span class="w"> </span><span class="n">atlasUV</span><span class="p">));</span>
<span class="p">}</span>
<span class="k">return</span><span class="w"> </span><span class="n">EncodeHDR</span><span class="p">(</span><span class="n">color</span><span class="p">);</span>
</code></pre></div>
<p><img alt="叠加好的图，分辨率和图集里最大的那张一样" src="../../../obsidian-vault/attachments/bloom-final.png" /></p>
<p>之后把它拿给 UberPost，加到屏幕上即可。</p>
<h3 id="防漏光">防漏光<a class="headerlink" href="#防漏光" title="Permanent link">&para;</a></h3>
<p>刚才叠加时是用 bilinear 采样的，在某张图边缘采样时可能采样到图集里的另一张图。解决方法是，在图和图之间加几个像素的 padding，一般 1 个像素就差不多了。</p>
<h2 id="完整代码">完整代码<a class="headerlink" href="#完整代码" title="Permanent link">&para;</a></h2>
<p><a href="https://github.com/stalomeow/StarRailNPRShader">GitHub: stalomeow/StarRailNPRShader</a></p>
<h2 id="参考文章">参考文章<a class="headerlink" href="#参考文章" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://gwb.tencent.com/community/detail/124756">米哈游技术总监首次分享：移动端高品质卡通渲染的实现与优化方案 -腾讯游戏学堂</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/525500877">高质量泛光（bloom）从理论到实战 - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/630726865">高质量泛光Bloom改进以及高斯核采样的优化 - 知乎</a></li>
</ul>
<h2 id="进一步阅读">进一步阅读<a class="headerlink" href="#进一步阅读" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/675125241">复刻 绝区零/原神 的Bloom效果 - 知乎</a>：Bloom 图集的另一种实现。</li>
<li><a href="https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">Efficient Gaussian blur with linear sampling – RasterGrid</a>：讲了多种优化手段，除了杨辉三角，还有借助 bilinear 减少采样数的方法。</li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://www.rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/">Efficient Gaussian blur with linear sampling – RasterGrid</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="https://stackoverflow.com/questions/15580291/how-to-efficiently-calculate-a-row-in-pascals-triangle">algorithm - How to efficiently calculate a row in pascal's triangle? - Stack Overflow</a>&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div><hr />