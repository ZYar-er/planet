这不比Windows爽<hr /><p>最近对于Bash愈发迷恋，几乎任何会花费我超过30秒时间的任务，我都会考虑<del>打个脚先</del>写个脚本搞定。再比如说写博客，这种纯输出流就很适合Vim啊，作为一个Vim<del>批</del>必然是原教旨主义最好啊：</p><p><img src="/img/Pasted%20image%2020230926235753.png" alt="算了截图还是用Obsidian粘吧"></p><p>但是除了截图粘贴不方便外，还有一些比较难受的地方。在Obsidian里边我是能直接用插件的各种功能快速编写博客的，虽然在Bash终端环境下编写脚本确实更方便了，但是脚本一多，目录就乱的不能看力：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 强迫症是病，得治</span></span><br><span class="line">.</span><br><span class="line">├── about</span><br><span class="line">├── _archive</span><br><span class="line">├── deploy.sh</span><br><span class="line">├── _draft</span><br><span class="line">├── how-much-did-i-write.sh</span><br><span class="line">├── img</span><br><span class="line">├── img-uri-process.sh</span><br><span class="line">├── _inbox</span><br><span class="line">├── links</span><br><span class="line">├── new-post.sh</span><br><span class="line">├── _posts</span><br><span class="line">└── _scaffolds</span><br><span class="line"></span><br><span class="line">9 directories, 4 files</span><br></pre></td></tr></table></figure><p>三个脚本，一个是统计字数的，一个是用<code>sed</code>处理图片链接的，还有一个是从模板新建博客的。每次打开目录看到这仨在中间总觉得很别扭。</p><p>除了这，还有就是用起来也不方便：前面要是不加<code>./</code>就能直接用就好了<del>懒也是病得治</del></p><p>所以，需求大概就是这样：目录级别的环境变量配置，并且支持还得够完善，不能离开目录了配置还在生效，不然脚本在其他目录跑飞了想想就恐怖。</p><h2 id="Basic-Implementation"><a href="#Basic-Implementation" class="headerlink" title="Basic Implementation"></a>Basic Implementation</h2><p>首先定位清楚，这个对<code>cd</code>的Hook只是在指令完成后，加载或者取消配置局部环境变量。因此大概实现方式和结构都有合适的选择。</p><ul><li>程序扔<code>~/.bashrc</code>里，或者<code>/etc/profile</code>里。不过我一般在GUI用konsole比较多，所以就放<code>.bashrc</code>里了，也方便dotfile管理。</li><li>把具体实现用<code>alias</code>赋别名为<code>cd</code>达到重载（或者说Hook)<code>cd</code>的目的。</li></ul><p>基于上面这两条，这是我写一个粗略实现（没干掉bash基本使用就是能用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">cd_hook</span></span>() &#123;</span><br><span class="line">    <span class="comment"># The normal cd</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$#</span> == 0 ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">cd</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> </span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">    <span class="comment"># If the dir contains bashrc, launch the sub shell and load it</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">&quot;.bashrc&quot;</span> ] &amp;&amp; [ <span class="string">&quot;<span class="subst">$(pwd)</span>&quot;</span> != <span class="string">&quot;<span class="subst">$(getent passwd $USER | awk -F &#x27;:&#x27; &#x27;&#123;print $6&#125;&#x27;)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">pushd</span> .  &gt; /dev/null</span><br><span class="line">        bash --init-file &lt;(<span class="built_in">cat</span> /etc/profile ~/.bashrc .bashrc)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">cd</span>=<span class="string">&#x27;cd_hook&#x27;</span></span><br></pre></td></tr></table></figure><p>上面有依托用来检测是否是家目录的指令来避免套娃（虽然理论上充重复加载家目录配置应该没啥）,然后是检测当前目录下（因为是先<code>cd</code>过去的嘛，所以<code>pwd</code>已经变了）是否有<code>.bashrc</code>，有的话就把它作为子参数，和家目录下的bashrc一起传给子bash，然后启动它。</p><p>这样就能实现cd后自动加载目录下的配置了。赶紧试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># My blog&#x27;s utiilties and aliases</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">TMPL=$(find ./_scaffolds | grep .md)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">deploy</span></span>() &#123;</span><br><span class="line">    <span class="built_in">cd</span> ..</span><br><span class="line">    (</span><br><span class="line">        <span class="built_in">rm</span> -rf deploy &amp;&amp; <span class="built_in">cp</span> -r blog deploy</span><br><span class="line">        <span class="built_in">cd</span> deploy &amp;&amp; git checkout deploy</span><br><span class="line">        <span class="built_in">cp</span> -r blog deploy/source</span><br><span class="line">        <span class="built_in">cd</span> deploy &amp;&amp; pnpm i &amp;&amp; pnpm run server</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">image_url_proc</span></span>() &#123;</span><br><span class="line">    find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.md&quot;</span> -<span class="built_in">exec</span> sed -i <span class="string">&#x27;s/\!\[\[\(.*\)\/\(.*\)\]\]/\!\[\2\]\(\/img\/\2\)/gi&#x27;</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">new_post</span></span>() &#123;</span><br><span class="line">    sed -e <span class="string">&quot;s/&#123;&#123;title&#125;&#125;/<span class="variable">$1</span>/&quot;</span> -e <span class="string">&quot;s/&#123;&#123;date&#125;&#125; &#123;&#123;time&#125;&#125;/<span class="subst">$(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)</span>/&quot;</span> <span class="variable">$TMPL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">line_count</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;You have wrote <span class="subst">$(find _* -name *.md | xargs cat 2&gt;/dev/null | wc -l)</span> lines in total!&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cd到目录里边试试<code>line_count</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xeonds@ark-station-breeze:~/Documents/blog$ line_count</span><br><span class="line">You have wrote 36570 lines <span class="keyword">in</span> total!</span><br><span class="line">xeonds@ark-station-breeze:~/Documents/blog$ </span><br></pre></td></tr></table></figure><p>好好好，再看看目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── .bashrc</span><br><span class="line">├── about</span><br><span class="line">├── _archive</span><br><span class="line">├── _draft</span><br><span class="line">├── img</span><br><span class="line">├── _inbox</span><br><span class="line">├── links</span><br><span class="line">├── _posts</span><br><span class="line">└── _scaffolds</span><br><span class="line"></span><br><span class="line"> 9 directories, 1 files</span><br></pre></td></tr></table></figure><p>爽死。</p><p>慢着，里边还有一行<code>pushd</code>呢。嗯，这是后面用来实现自动退出子Shell的关键。具体实现等到下一部分再说吧，先睡了。</p><p>后来感觉这样有点太麻烦了，于是就把脚本简化了一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">cd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">builtin</span> <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [[ -f <span class="string">&quot;<span class="variable">$PWD</span>/.bashrc&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">exec</span> bash --rcfile &lt;(<span class="built_in">cat</span> ~/.bashrc <span class="string">&quot;<span class="variable">$PWD</span>/.bashrc&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">exec</span> bash --rcfile &lt;(<span class="built_in">cat</span> ~/.bashrc)</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑很简单，先直通参数执行完内置<code>cd</code>，然后判断目的目录底下有没有<code>.bashrc</code>，有的话直接<code>exec</code>一个新的bash来加载这个配置文件和<code>~/</code>下的默认配置；如果没有的话，也<code>exec</code>一个新的bash替换当前进程。</p><p>之所以到一个新目录都要开一个新的进程替换当前进程，是为了使得只有在当前目录底下才可以使用当前文件夹的环境变量。不过这也带来了新的问题：那就是执行一些包含<code>cd</code>的脚本时，会因为<code>exec</code>用新的进程覆盖了当前进程的原因，导致脚本执行终止。</p><p>最后想了下，Makefile不也挺好用的（笑）。</p>