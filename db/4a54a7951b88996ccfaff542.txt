<h1 id="对逐物体阴影的一些改进">对逐物体阴影的一些改进<a class="headerlink" href="#对逐物体阴影的一些改进" title="Permanent link">&para;</a></h1>
<!-- more -->

<p>之前在<a href="../toon-main-light-character-shadow/">仿星铁渲染：主光源角色阴影</a>里提到了逐物体阴影的写法，这次要对之前的写法做一点改进。</p>
<h2 id="改正-View-Matrix-的计算">改正 View Matrix 的计算<a class="headerlink" href="#改正-View-Matrix-的计算" title="Permanent link">&para;</a></h2>
<p>约定</p>
<ul>
<li><span class="arithmatex">\(\mathbf{T}\)</span> 表示 <code>translate(aabbCenter)</code></li>
<li><span class="arithmatex">\(\mathbf{R}\)</span> 表示 <code>rotate(lightRotation)</code></li>
<li><span class="arithmatex">\(\mathbf{S}\)</span> 表示 <code>scale(1, 1, 1)</code></li>
<li><span class="arithmatex">\(\mathbf{Z}\)</span> 表示翻转 Z 轴</li>
<li><span class="arithmatex">\(\mathbf{w}\)</span> 表示 World Space 的点</li>
<li><span class="arithmatex">\(\mathbf{v}\)</span> 表示将 <span class="arithmatex">\(\mathbf{w}\)</span> 变换到 View Space 后得到的点</li>
</ul>
<p>有公式</p>
<div class="arithmatex">\[
\mathbf{w}=\mathbf{T}\mathbf{R}\mathbf{S}\mathbf{Z}\mathbf{v}
\]</div>
<p>所以</p>
<div class="arithmatex">\[
\text{View Matrix}=\mathbf{Z}^{-1}\mathbf{S}^{-1}\mathbf{R}^{-1}\mathbf{T}^{-1}
\]</div>
<p>考虑到 <span class="arithmatex">\(\mathbf{Z}^{-1}=\mathbf{Z}\)</span> 且 <span class="arithmatex">\(\mathbf{S}^{-1}=\mathbf{S}\)</span>，所以下面几个公式也对</p>
<div class="arithmatex">\[
\text{View Matrix}=\mathbf{Z}\mathbf{S}\mathbf{R}^{-1}\mathbf{T}^{-1}=\mathbf{Z} (\mathbf{T}\mathbf{R}\mathbf{S})^{-1}
\]</div>
<p>之前脑抽了，写成</p>
<div class="highlight"><pre><span></span><code><span class="n">float4x4</span><span class="w"> </span><span class="n">viewMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float4x4</span><span class="p">.</span><span class="n">TRS</span><span class="p">(</span><span class="o">-</span><span class="n">aabbCenter</span><span class="p">,</span><span class="w"> </span><span class="n">inverse</span><span class="p">(</span><span class="n">lightRotation</span><span class="p">),</span><span class="w"> </span><span class="m">1</span><span class="p">);</span>
<span class="n">viewMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">s_FlipZMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">viewMatrix</span><span class="p">);</span><span class="w"> </span><span class="c1">// 翻转 z 轴</span>
</code></pre></div>
<p>即</p>
<div class="arithmatex">\[
\mathbf{Z}\mathbf{T}^{-1}\mathbf{R}^{-1}\mathbf{S}
\]</div>
<p>显然是错的。正确的计算方法是</p>
<div class="highlight"><pre><span></span><code><span class="n">float4x4</span><span class="w"> </span><span class="n">viewMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inverse</span><span class="p">(</span><span class="n">float4x4</span><span class="p">.</span><span class="n">TRS</span><span class="p">(</span><span class="n">aabbCenter</span><span class="p">,</span><span class="w"> </span><span class="n">lightRotation</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">));</span>
<span class="n">viewMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">s_FlipZMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">viewMatrix</span><span class="p">);</span><span class="w"> </span><span class="c1">// 翻转 z 轴</span>
</code></pre></div>
<p>这个问题在之前的文章里也修改了。</p>
<h2 id="改进-Projection-Matrix-的计算">改进 Projection Matrix 的计算<a class="headerlink" href="#改进-Projection-Matrix-的计算" title="Permanent link">&para;</a></h2>
<blockquote>
<p>这里只考虑主平行光源，也就是正交投影。</p>
</blockquote>
<p><img alt="剔除效果" src="../../../obsidian-vault/attachments/per-object-shadow-debugger.gif" /></p>
<p>这个方法的优势：</p>
<ol>
<li>准确地剔除看不见的阴影。</li>
<li><code>zNear</code> 和 <code>zFar</code> 的距离是最小的，不浪费 ShadowMap 的精度。</li>
</ol>
<h3 id="思路">思路<a class="headerlink" href="#思路" title="Permanent link">&para;</a></h3>
<p>把角色的 AABB 用之前算的 View Matrix 转到光源 View Space 后，看起来就像下面这样。</p>
<p><img alt="View Space 中的角色包围盒" src="../../../obsidian-vault/attachments/Pasted%20image%2020240923204753.png" /></p>
<p>这个包围盒就是角色可投射阴影的区域，也是光源的视锥体。为了控制可投射阴影的最大距离，需要调整 <code>zFar</code>。但 <code>zFar</code> 距离 <code>zNear</code> 过远，会导致 ShadowMap 中深度都集中在 0 或者 1 附近，浪费精度，阴影质量也差。</p>
<p>比较好的算法是，在光源的 View Space 中对主相机视锥体进行切割，得到处于上图中矩形范围内的部分，将这部分 Z 坐标的最小值作为 <code>zFar</code>。这样，光源视锥体恰好能包住主相机视锥体的有效部分。</p>
<p>考虑到有时候主相机的视锥体比较长，用上面的方法算出的 <code>zFar</code> 距离 <code>zNear</code> 也很远，所以最后还是要再限制一下 <code>zFar - zNear</code> 的值。</p>
<h3 id="计算阴影包围盒">计算阴影包围盒<a class="headerlink" href="#计算阴影包围盒" title="Permanent link">&para;</a></h3>
<p>将角色的 World Space 包围盒变换到光源 View Space。</p>
<div class="highlight"><pre><span></span><code><span class="na">[MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
<span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">GetViewSpaceShadowAABB</span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">ShadowCasterCullingArgs</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="k">in</span><span class="w"> </span><span class="n">float4x4</span><span class="w"> </span><span class="n">viewMatrix</span><span class="p">,</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">,</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 8 个顶点</span>
<span class="w">    </span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">stackalloc</span><span class="w"> </span><span class="n">float4</span><span class="p">[</span><span class="m">8</span><span class="p">]</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">AABBMin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span>
<span class="w">        </span><span class="n">float4</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">AABBMax</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">),</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="n">shadowMin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float3</span><span class="p">(</span><span class="kt">float</span><span class="p">.</span><span class="n">PositiveInfinity</span><span class="p">);</span>
<span class="w">    </span><span class="n">shadowMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float3</span><span class="p">(</span><span class="kt">float</span><span class="p">.</span><span class="n">NegativeInfinity</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">8</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">xyz</span><span class="p">;</span>
<span class="w">        </span><span class="n">shadowMin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">shadowMin</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="n">shadowMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">shadowMax</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">Usage</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ShadowUsage</span><span class="p">.</span><span class="n">Scene</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 理论上场景阴影可以打到无穷远处，但包围盒太长的话深度都集中在 0 或者 1 处，精度不够</span>
<span class="w">        </span><span class="c1">// 目前限制最多向后扩展 100 个单位</span>
<span class="w">        </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">100</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>上面的代码在最后把 <code>shadowMin.z (zFar)</code> 向后扩展到 100 个单位，表示阴影最多往后投射 100 米，超出这个包围盒就没有阴影了。</p>
<h3 id="简化主相机视锥体">简化主相机视锥体<a class="headerlink" href="#简化主相机视锥体" title="Permanent link">&para;</a></h3>
<p>主相机的视锥体是个棱台，将它的每个面沿任意对角线拆成 2 个三角形，最后得到 12 个三角形。使用三角形能简化后面的计算。</p>
<p>实现时，采用 Mesh 里 Vertex Buffer 和 Index Buffer 的思想，先拿到视锥体的 8 个顶点。</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="n">Vector3</span><span class="p">[]</span><span class="w"> </span><span class="n">s_FrustumCornerBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Vector3</span><span class="p">[</span><span class="m">4</span><span class="p">];</span>

<span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">SetFrustumEightCorners</span><span class="p">(</span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">frustumEightCorners</span><span class="p">,</span><span class="w"> </span><span class="n">Camera</span><span class="w"> </span><span class="n">camera</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">Camera</span><span class="p">.</span><span class="n">MonoOrStereoscopicEye</span><span class="w"> </span><span class="n">Eye</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Camera</span><span class="p">.</span><span class="n">MonoOrStereoscopicEye</span><span class="p">.</span><span class="n">Mono</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// https://docs.unity3d.com/6000.0/Documentation/ScriptReference/Camera.CalculateFrustumCorners.html</span>
<span class="w">    </span><span class="c1">// The order of the corners is lower left, upper left, upper right, lower right.</span>

<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">viewport</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Rect</span><span class="p">(</span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">);</span>
<span class="w">    </span><span class="n">Transform</span><span class="w"> </span><span class="n">cameraTransform</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">transform</span><span class="p">;</span>

<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">CalculateFrustumCorners</span><span class="p">(</span><span class="n">viewport</span><span class="p">,</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">nearClipPlane</span><span class="p">,</span><span class="w"> </span><span class="n">Eye</span><span class="p">,</span><span class="w"> </span><span class="n">s_FrustumCornerBuffer</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Vector3</span><span class="w"> </span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cameraTransform</span><span class="p">.</span><span class="n">TransformPoint</span><span class="p">(</span><span class="n">s_FrustumCornerBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="n">frustumEightCorners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">float4</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">CalculateFrustumCorners</span><span class="p">(</span><span class="n">viewport</span><span class="p">,</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">farClipPlane</span><span class="p">,</span><span class="w"> </span><span class="n">Eye</span><span class="p">,</span><span class="w"> </span><span class="n">s_FrustumCornerBuffer</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">Vector3</span><span class="w"> </span><span class="n">xyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cameraTransform</span><span class="p">.</span><span class="n">TransformPoint</span><span class="p">(</span><span class="n">s_FrustumCornerBuffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="n">frustumEightCorners</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">4</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">float4</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>然后，给出一个索引列表，这个不唯一，也不用考虑顺时针或逆时针。我是用下面的方式拆分的。</p>
<p><img alt="拆分成三角形" src="../../../obsidian-vault/attachments/Pasted%20image%2020240923211259.png" /></p>
<div class="highlight"><pre><span></span><code><span class="k">public</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">FrustumTriangleCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">12</span><span class="p">;</span>

<span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="kt">int</span><span class="p">[]</span><span class="w"> </span><span class="n">FrustumTriangleIndices</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="p">[</span><span class="n">FrustumTriangleCount</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">3</span><span class="p">]</span>
<span class="p">{</span>
<span class="w">    </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span>
<span class="w">    </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span>
<span class="w">    </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span>
<span class="w">    </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span>
<span class="w">    </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span>
<span class="w">    </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="p">,</span>
<span class="w">    </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="p">,</span>
<span class="w">    </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="p">,</span>
<span class="w">    </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">3</span><span class="p">,</span>
<span class="w">    </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span>
<span class="w">    </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">5</span><span class="p">,</span>
<span class="w">    </span><span class="m">5</span><span class="p">,</span><span class="w"> </span><span class="m">7</span><span class="p">,</span><span class="w"> </span><span class="m">6</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="裁剪主相机视锥体">裁剪主相机视锥体<a class="headerlink" href="#裁剪主相机视锥体" title="Permanent link">&para;</a></h3>
<p>将刚才那 12 个三角形变换到 View Space 后，暂时不考虑 Z 轴，裁剪出阴影包围盒矩形区域中的部分。</p>
<p>先考虑一个三角形被一条线裁剪的情况。</p>
<p><img alt="一个点在内部" src="../../../obsidian-vault/attachments/Pasted%20image%2020240924000446.png" /></p>
<p>三个点都在内部，或者都不在内部的情况就不说了。只有一个点 <span class="arithmatex">\(A\)</span> 在内部时，如上图。根据相似三角形很容易算出 <span class="arithmatex">\(P\)</span> 和 <span class="arithmatex">\(Q\)</span> 点的坐标，进而将 <span class="arithmatex">\(\triangle ABC\)</span> 裁剪为 <span class="arithmatex">\(\triangle APQ\)</span>。两个点在内部的情况和上面类似，只是裁剪出来是一个四边形，要再拆成两个三角形。</p>
<p>一个三角形被一个矩形裁剪，相当于依次被这个矩形的 4 条边裁剪。最坏情况下，每个三角形每次都是两个点在内部，被裁剪成两个三角形，最后变成 16（2 的 4 次方）个三角形。</p>
<p>对 12 个三角形依次做上述裁剪，视锥体就被裁剪完成了。如果一个三角形都没剩下，说明阴影不可见。有三角形的话，就计算它们的 <code>minZ</code> 和 <code>maxZ</code>，如果满足 <code>minZ &lt; shadowMax.z &amp;&amp; maxZ &gt; shadowMin.z</code>，阴影就是可见的，修改 <code>shadowMin.z = max(shadowMin.z, minZ)</code>。</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">TriangleData</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">P0</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">P1</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">P2</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">IsCulled</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">private</span><span class="w"> </span><span class="k">enum</span><span class="w"> </span><span class="n">EdgeType</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Min</span><span class="p">,</span>
<span class="w">    </span><span class="n">Max</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">private</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">EdgeData</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">ComponentIndex</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Value</span><span class="p">;</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="n">EdgeType</span><span class="w"> </span><span class="n">Type</span><span class="p">;</span>
<span class="p">}</span>

<span class="na">[MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
<span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">AdjustViewSpaceShadowAABB</span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">ShadowCasterCullingArgs</span><span class="w"> </span><span class="n">args</span><span class="p">,</span>
<span class="w">    </span><span class="k">in</span><span class="w"> </span><span class="n">float4x4</span><span class="w"> </span><span class="n">viewMatrix</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">float3</span><span class="o">*</span><span class="w"> </span><span class="n">frustumCorners</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">stackalloc</span><span class="w"> </span><span class="n">float3</span><span class="p">[</span><span class="n">ShadowCasterCullingArgs</span><span class="p">.</span><span class="n">FrustumCornerCount</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ShadowCasterCullingArgs</span><span class="p">.</span><span class="n">FrustumCornerCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">frustumCorners</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">viewMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">FrustumEightCorners</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">xyz</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">EdgeData</span><span class="o">*</span><span class="w"> </span><span class="n">edges</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">stackalloc</span><span class="w"> </span><span class="n">EdgeData</span><span class="p">[</span><span class="m">4</span><span class="p">]</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">new</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ComponentIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EdgeType</span><span class="p">.</span><span class="n">Min</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="k">new</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ComponentIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EdgeType</span><span class="p">.</span><span class="n">Max</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="k">new</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ComponentIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EdgeType</span><span class="p">.</span><span class="n">Min</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="k">new</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">ComponentIndex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">Value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EdgeType</span><span class="p">.</span><span class="n">Max</span><span class="w"> </span><span class="p">},</span>
<span class="w">    </span><span class="p">};</span>

<span class="w">    </span><span class="c1">// 最坏情况：1 个三角形被拆成 2**4 = 16 个三角形</span>
<span class="w">    </span><span class="n">TriangleData</span><span class="o">*</span><span class="w"> </span><span class="n">triangles</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">stackalloc</span><span class="w"> </span><span class="n">TriangleData</span><span class="p">[</span><span class="m">16</span><span class="p">];</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isVisibleXY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">minZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">.</span><span class="n">PositiveInfinity</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">maxZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">.</span><span class="n">NegativeInfinity</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ShadowCasterCullingArgs</span><span class="p">.</span><span class="n">FrustumTriangleCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">triangleCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">triangles</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">P0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frustumCorners</span><span class="p">[</span><span class="n">ShadowCasterCullingArgs</span><span class="p">.</span><span class="n">FrustumTriangleIndices</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">0</span><span class="p">]];</span>
<span class="w">        </span><span class="n">triangles</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">P1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frustumCorners</span><span class="p">[</span><span class="n">ShadowCasterCullingArgs</span><span class="p">.</span><span class="n">FrustumTriangleIndices</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">1</span><span class="p">]];</span>
<span class="w">        </span><span class="n">triangles</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">P2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">frustumCorners</span><span class="p">[</span><span class="n">ShadowCasterCullingArgs</span><span class="p">.</span><span class="n">FrustumTriangleIndices</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">2</span><span class="p">]];</span>
<span class="w">        </span><span class="n">triangles</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="n">IsCulled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">4</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">triangleCount</span><span class="p">;</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">CullTriangle</span><span class="p">(</span><span class="n">triangles</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">k</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">triangleCount</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">triangleCount</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">ref</span><span class="w"> </span><span class="n">TriangleData</span><span class="w"> </span><span class="n">tri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">triangles</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tri</span><span class="p">.</span><span class="n">IsCulled</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="k">continue</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="n">isVisibleXY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">            </span><span class="n">minZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">minZ</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">.</span><span class="n">z</span><span class="p">)));</span>
<span class="w">            </span><span class="n">maxZ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">maxZ</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">.</span><span class="n">z</span><span class="p">)));</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isVisibleXY</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">minZ</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">maxZ</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 为了阴影的完整性，不应该修改 shadowMax.z</span>
<span class="w">        </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">minZ</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="na">[MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
<span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">CullTriangle</span><span class="p">([</span><span class="n">NoAlias</span><span class="p">]</span><span class="w"> </span><span class="n">TriangleData</span><span class="o">*</span><span class="w"> </span><span class="n">triangles</span><span class="p">,</span>
<span class="w">    </span><span class="k">ref</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">triangleIndex</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">triangleCount</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">EdgeData</span><span class="w"> </span><span class="n">edge</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">ref</span><span class="w"> </span><span class="n">TriangleData</span><span class="w"> </span><span class="n">tri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">triangles</span><span class="p">[</span><span class="n">triangleIndex</span><span class="p">];</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tri</span><span class="p">.</span><span class="n">IsCulled</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">insideInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="n">b000</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsPointInsideEdge</span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">edge</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">))</span><span class="w"> </span><span class="n">insideInfo</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="m">0</span><span class="n">b001</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsPointInsideEdge</span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">edge</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="p">))</span><span class="w"> </span><span class="n">insideInfo</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="m">0</span><span class="n">b010</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">IsPointInsideEdge</span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">edge</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">))</span><span class="w"> </span><span class="n">insideInfo</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="m">0</span><span class="n">b100</span><span class="p">;</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isOnePointInside</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 将在边界里的点移动到 [P0, P1, P2] 列表的前面</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">insideInfo</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 没有点在里面</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="m">0</span><span class="n">b000</span><span class="p">:</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">IsCulled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 有一个点在里面</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="m">0</span><span class="n">b001</span><span class="p">:</span><span class="w"> </span><span class="n">isOnePointInside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="m">0</span><span class="n">b010</span><span class="p">:</span><span class="w"> </span><span class="n">isOnePointInside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span><span class="w"> </span><span class="n">Swap</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="m">0</span><span class="n">b100</span><span class="p">:</span><span class="w"> </span><span class="n">isOnePointInside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span><span class="w"> </span><span class="n">Swap</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 有两个点在里面</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="m">0</span><span class="n">b011</span><span class="p">:</span><span class="w"> </span><span class="n">isOnePointInside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="m">0</span><span class="n">b101</span><span class="p">:</span><span class="w"> </span><span class="n">isOnePointInside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span><span class="w"> </span><span class="n">Swap</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="m">0</span><span class="n">b110</span><span class="p">:</span><span class="w"> </span><span class="n">isOnePointInside</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span><span class="w"> </span><span class="n">Swap</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">);</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 所有点在里面</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="m">0</span><span class="n">b111</span><span class="p">:</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// Unreachable</span>
<span class="w">        </span><span class="k">default</span><span class="p">:</span><span class="w"> </span><span class="n">Debug</span><span class="p">.</span><span class="n">LogError</span><span class="p">(</span><span class="s">&quot;Unknown triangleInsideInfo&quot;</span><span class="p">);</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">isOnePointInside</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 只有 P0 在里面</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">v01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">;</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">v02</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">;</span>

<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edge</span><span class="p">.</span><span class="n">Value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">ComponentIndex</span><span class="p">];</span>
<span class="w">        </span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v01</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rcp</span><span class="p">(</span><span class="n">v01</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">ComponentIndex</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">;</span>
<span class="w">        </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v02</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rcp</span><span class="p">(</span><span class="n">v02</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">ComponentIndex</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// 只有 P2 在外面</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">v20</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">;</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">v21</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">;</span>

<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">edge</span><span class="p">.</span><span class="n">Value</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">ComponentIndex</span><span class="p">];</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">p0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v20</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rcp</span><span class="p">(</span><span class="n">v20</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">ComponentIndex</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">;</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v21</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rcp</span><span class="p">(</span><span class="n">v21</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">ComponentIndex</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 第一个三角形</span>
<span class="w">        </span><span class="n">tri</span><span class="p">.</span><span class="n">P2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p0</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 把下一个三角形拷贝到列表最后新的位置上，然后把新三角形数据写入到下个位置</span>
<span class="w">        </span><span class="c1">// 新的三角形必定三个点都在边界内，所以 ++triangleIndex 跳过检查</span>
<span class="w">        </span><span class="k">ref</span><span class="w"> </span><span class="n">TriangleData</span><span class="w"> </span><span class="n">newTri</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">triangles</span><span class="p">[</span><span class="o">++</span><span class="n">triangleIndex</span><span class="p">];</span>
<span class="w">        </span><span class="n">triangles</span><span class="p">[</span><span class="n">triangleCount</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newTri</span><span class="p">;</span>

<span class="w">        </span><span class="c1">// 第二个三角形</span>
<span class="w">        </span><span class="n">newTri</span><span class="p">.</span><span class="n">P0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p0</span><span class="p">;</span>
<span class="w">        </span><span class="n">newTri</span><span class="p">.</span><span class="n">P1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tri</span><span class="p">.</span><span class="n">P1</span><span class="p">;</span>
<span class="w">        </span><span class="n">newTri</span><span class="p">.</span><span class="n">P2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p1</span><span class="p">;</span>
<span class="w">        </span><span class="n">newTri</span><span class="p">.</span><span class="n">IsCulled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="na">[MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
<span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">IsPointInsideEdge</span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">EdgeData</span><span class="w"> </span><span class="n">edge</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// EdgeType.Min =&gt; p[edge.ComponentIndex] &gt; edge.Value</span>
<span class="w">    </span><span class="c1">// EdgeType.Max =&gt; p[edge.ComponentIndex] &lt; edge.Value</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="n">edge</span><span class="p">.</span><span class="n">ComponentIndex</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">edge</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nf">select</span><span class="p">(</span><span class="o">-</span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">delta</span><span class="p">,</span><span class="w"> </span><span class="n">edge</span><span class="p">.</span><span class="n">Type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">EdgeType</span><span class="p">.</span><span class="n">Min</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="na">[MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
<span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Swap</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span>
</code></pre></div>
<h3 id="计算-Projection-Matrix">计算 Projection Matrix<a class="headerlink" href="#计算-Projection-Matrix" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">height</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">zNear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">shadowMax</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">zFar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="n">float4x4</span><span class="w"> </span><span class="n">projectionMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float4x4</span><span class="p">.</span><span class="n">Ortho</span><span class="p">(</span><span class="n">width</span><span class="p">,</span><span class="w"> </span><span class="n">height</span><span class="p">,</span><span class="w"> </span><span class="n">zNear</span><span class="p">,</span><span class="w"> </span><span class="n">zFar</span><span class="p">);</span>
</code></pre></div>
<h2 id="动态计算包围盒-vs-静态包围盒">动态计算包围盒 vs 静态包围盒<a class="headerlink" href="#动态计算包围盒-vs-静态包围盒" title="Permanent link">&para;</a></h2>
<p>在我的实现中，角色包围盒是根据 <code>Renderer.bounds</code> 动态计算的。有人说，动态计算会使包围盒一直变化，导致投影矩阵一直变化，进而出现阴影抖动，所以直接在 Inspector 里指定一个固定大小的包围盒更好。</p>
<p>我这样写的初衷是减少插件暴露出去的参数数量，降低使用门槛。不然，总有人不看文档，乱填参数，然后来私信问我。固定大小的包围盒要是设置的不够大，会导致阴影不完整。</p>
<p>另外，动态计算的包围盒不会一直变化，只有 <code>Renderer.bounds</code> 变了，计算结果才会变（可以看上面的动图）。<code>Renderer.bounds</code> 通常只在播放 <code>AnimationClip</code> 时才会变化，这个时候角色都在动了，阴影肯定会有一点抖动。我测试下来，角色运动时，包围盒的轻微变化不会对阴影质量造成很大的影响。</p>
<p>不过，能用静态包围盒还是用静态的，毕竟计算量少，代码也好写。</p>
<h2 id="完整代码">完整代码<a class="headerlink" href="#完整代码" title="Permanent link">&para;</a></h2>
<p><a href="https://github.com/stalomeow/StarRailNPRShader">stalomeow/StarRailNPRShader: Fan-made shaders for Unity URP attempting to replicate the shading of Honkai: Star Rail. (github.com)</a></p><hr />