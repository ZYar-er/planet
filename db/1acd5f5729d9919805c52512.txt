<h1 id="仿星铁渲染主光源角色阴影">仿星铁渲染：主光源角色阴影<a class="headerlink" href="#仿星铁渲染主光源角色阴影" title="Permanent link">&para;</a></h1>
<!-- more -->

<p>角色阴影使用了逐物体阴影技术。因为代码有点多，所以只挑一些关键的写。</p>
<h2 id="逐物体阴影">逐物体阴影<a class="headerlink" href="#逐物体阴影" title="Permanent link">&para;</a></h2>
<p>逐物体阴影（Per-Object Shadow）就是给物体单独生成一张 Shadow Map，解决物体在默认的 Cascaded Shadow Map 上占比较小，阴影精度低的问题，顺便还能把场景阴影和角色阴影分开。</p>
<p><img alt="Per-Object Shadow Map，角色尽可能撑满整张图" src="../../../obsidian-vault/attachments/per-object-shadow-map.png" /></p>
<p>代码大体上按照 URP 的 <a href="https://github.com/Unity-Technologies/Graphics/blob/master/Packages/com.unity.render-pipelines.universal/Runtime/Passes/MainLightShadowCasterPass.cs"><code>MainLightShadowCasterPass</code></a> 写，但是一些矩阵需要自己计算。</p>
<h3 id="角色包围盒">角色包围盒<a class="headerlink" href="#角色包围盒" title="Permanent link">&para;</a></h3>
<p>要让角色尽可能撑满 Shadow Map，就需要知道角色的包围盒。两种方法：</p>
<ol>
<li>直接设置一个固定大小的 Box。</li>
<li>找到角色身上所有投射阴影的 <a href="https://docs.unity3d.com/ScriptReference/Renderer-bounds.html"><code>Renderer.bounds</code></a>，将它们合并起来。</li>
</ol>
<p>考虑到播放 AnimationClip 时，角色包围盒会发生变化，我选择第二种方法。</p>
<h3 id="计算-View-Matrix">计算 View Matrix<a class="headerlink" href="#计算-View-Matrix" title="Permanent link">&para;</a></h3>
<p>把主光源当成相机，再移动到角色包围盒中心，就有一个 View Space。View Matrix 的作用是将 World Space 变换为这个 View Space。</p>
<div class="highlight"><pre><span></span><code><span class="n">float4x4</span><span class="w"> </span><span class="n">viewMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inverse</span><span class="p">(</span><span class="n">float4x4</span><span class="p">.</span><span class="n">TRS</span><span class="p">(</span><span class="n">aabbCenter</span><span class="p">,</span><span class="w"> </span><span class="n">lightRotation</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">));</span>
<span class="n">viewMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">s_FlipZMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">viewMatrix</span><span class="p">);</span><span class="w"> </span><span class="c1">// 翻转 z 轴</span>
</code></pre></div>
<p>View Space 是 -Z 朝前的右手坐标系。<code>s_FlipZMatrix</code> 即</p>
<div class="arithmatex">\[
\begin{bmatrix}
1 &amp;0  &amp;0  &amp;0 \\
0 &amp;1  &amp;0  &amp;0 \\
0 &amp;0  &amp;-1 &amp;0 \\
0 &amp;0  &amp;0  &amp;1
\end{bmatrix}
\]</div>
<p>用来翻转 Z 轴。</p>
<h3 id="剔除">剔除<a class="headerlink" href="#剔除" title="Permanent link">&para;</a></h3>
<p>为了节约资源，看不见的阴影应该提前剔除掉。想准确剔除是很困难的，所以最后我实现了一个 View Space 下的快速且保守的剔除算法。</p>
<p>首先，要把角色包围盒和视锥体变换到 View Space，然后计算变换后的 AABB。具体讲，就是把它们的 8 个顶点变换一下，然后重新计算 Min 和 Max。Unity 提供了 <a href="https://docs.unity3d.com/ScriptReference/GeometryUtility.CalculateBounds.html"><code>GeometryUtility.CalculateBounds</code></a> 方法。不过我这里要用 Burst，就自己写了一个。视锥体的 8 个顶点可以用 <a href="https://docs.unity3d.com/ScriptReference/Camera.CalculateFrustumCorners.html"><code>Camera.CalculateFrustumCorners</code></a> 提前计算好。</p>
<div class="highlight"><pre><span></span><code><span class="na">[MethodImpl(MethodImplOptions.AggressiveInlining)]</span>
<span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">EightPointsAABB</span><span class="p">([</span><span class="n">NoAlias</span><span class="p">]</span><span class="w"> </span><span class="n">float4</span><span class="o">*</span><span class="w"> </span><span class="n">points</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">float4x4</span><span class="w"> </span><span class="n">transform</span><span class="p">,</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">aabbMin</span><span class="p">,</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">float3</span><span class="w"> </span><span class="n">aabbMax</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">aabbMin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float3</span><span class="p">(</span><span class="kt">float</span><span class="p">.</span><span class="n">PositiveInfinity</span><span class="p">);</span>
<span class="w">    </span><span class="n">aabbMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float3</span><span class="p">(</span><span class="kt">float</span><span class="p">.</span><span class="n">NegativeInfinity</span><span class="p">);</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">8</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">float3</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mul</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span><span class="w"> </span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">xyz</span><span class="p">;</span>
<span class="w">        </span><span class="n">aabbMin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">aabbMin</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">        </span><span class="n">aabbMax</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="n">aabbMax</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>检查角色 AABB 和视锥体 AABB，如果没有相交的话，这个阴影就看不见，需要被剔除。</p>
<div class="highlight"><pre><span></span><code><span class="c1">// shadowMin 和 shadowMax 是角色 AABB</span>
<span class="c1">// frustumMin 和 frustumMax 是视锥体 AABB</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">any</span><span class="p">(</span><span class="n">shadowMax</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">frustumMin</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">any</span><span class="p">(</span><span class="n">shadowMin</span><span class="p">.</span><span class="n">xy</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">frustumMax</span><span class="p">.</span><span class="n">xy</span><span class="p">))</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 剔除</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>
<p>如果是角色投射到场景的阴影，理论上它可以打到无穷远处，<code>shadowMin.z</code> 需要当成负无穷处理，所以在做相交检测时，<code>any(shadowMin.xy &gt; frustumMax.xy)</code> 这一半不需要检查 <code>z</code>。然后，要向后延长角色包围盒，包住自己还有这部分视锥体里的物体。但包围盒太长的话深度都集中在 0 或者 1 处，精度不够，所以必须要限制一下长度。</p>
<div class="highlight"><pre><span></span><code><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp</span><span class="p">(</span><span class="n">frustumMin</span><span class="p">.</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">100</span><span class="p">,</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="p">);</span>
</code></pre></div>
</li>
<li>
<p>如果是角色的自阴影，它只会投射在自己身上，不会到无穷远处，可以检查 z 方向进一步剔除。</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">frustumMax</span><span class="p">.</span><span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 剔除</span>
<span class="p">}</span>
</code></pre></div>
</li>
</ul>
<h3 id="计算-Projection-Matrix">计算 Projection Matrix<a class="headerlink" href="#计算-Projection-Matrix" title="Permanent link">&para;</a></h3>
<p>主光源（平行光）用的是正交投影，光源视锥体要恰好包住角色，让角色撑满 Shadow Map。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">bottom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">shadowMax</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">zNear</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">shadowMax</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">zFar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">shadowMin</span><span class="p">.</span><span class="n">z</span><span class="p">;</span>
<span class="n">float4x4</span><span class="w"> </span><span class="n">projectionMatrix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float4x4</span><span class="p">.</span><span class="n">OrthoOffCenter</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">bottom</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">zNear</span><span class="p">,</span><span class="w"> </span><span class="n">zFar</span><span class="p">);</span>
</code></pre></div>
<p>Unity 的文档中提到</p>
<blockquote>
<p>The returned matrix embeds a z-flip operation whose purpose is to cancel the z-flip performed by the camera view matrix. If the view matrix is an identity or some custom matrix that doesn't perform a z-flip, consider multiplying the third column of the projection matrix (i.e. m02, m12, m22 and m32) by -1. <sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup></p>
</blockquote>
<p>即 <a href="https://docs.unity3d.com/ScriptReference/Matrix4x4.Ortho.html"><code>Matrix4x4.Ortho</code></a> 和 <a href="https://docs.unity3d.com/Packages/com.unity.mathematics@1.2/api/Unity.Mathematics.float4x4.OrthoOffCenter.html#Unity_Mathematics_float4x4_OrthoOffCenter_System_Single_System_Single_System_Single_System_Single_System_Single_System_Single_"><code>float4x4.OrthoOffCenter</code></a> 用的公式是</p>
<div class="arithmatex">\[
\text{zNear} \le -z \le \text{zFar}
\]</div>
<p>在我们的代码里对应</p>
<div class="arithmatex">\[
-\text{shadowMax.z} \le -z \le -\text{shadowMin.z}
\]</div>
<h3 id="筛选">筛选<a class="headerlink" href="#筛选" title="Permanent link">&para;</a></h3>
<p>剔除之后，可能还有非常多可见的阴影，需要给它们算一个优先级，然后进一步筛选。我规定 <code>priority</code> 值越小，就越优先绘制，最多绘制 <span class="arithmatex">\(k\)</span> 个。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">distSq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">distancesq</span><span class="p">(</span><span class="n">aabbCenter</span><span class="p">,</span><span class="w"> </span><span class="n">cameraPosition</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cosAngle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">cameraForward</span><span class="p">,</span><span class="w"> </span><span class="n">normalizesafe</span><span class="p">(</span><span class="n">aabbCenter</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cameraPosition</span><span class="p">));</span>
<span class="kt">float</span><span class="w"> </span><span class="n">priority</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saturate</span><span class="p">(</span><span class="n">distSq</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">1</span><span class="n">e4f</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">mad</span><span class="p">(</span><span class="o">-</span><span class="n">cosAngle</span><span class="p">,</span><span class="w"> </span><span class="m">0.5f</span><span class="p">,</span><span class="w"> </span><span class="m">0.5f</span><span class="p">);</span>
</code></pre></div>
<p>筛选过程本质上就是，从 <span class="arithmatex">\(n\)</span> 个数中找出前 <span class="arithmatex">\(k\)</span> 小元素的问题，对筛选出的 <span class="arithmatex">\(k\)</span> 个元素的顺序是没有要求的。可以维护一个大小为 <span class="arithmatex">\(k\)</span> 的大顶堆来实现，时间复杂度是 <span class="arithmatex">\(O(n \log k)\)</span>。我取的 <span class="arithmatex">\(k=16\)</span>。</p>
<h3 id="绘制阴影图集">绘制阴影图集<a class="headerlink" href="#绘制阴影图集" title="Permanent link">&para;</a></h3>
<p>根据阴影数量开一张大的 Shadow RT 作为图集，每个阴影占据其中的一块区域（tile）。绘制的时候，先算 tile 的位置，然后设置 Viewport，用 ScissorRect 加一点 padding，最后再画。</p>
<div class="highlight"><pre><span></span><code><span class="n">cmd</span><span class="p">.</span><span class="n">SetViewProjectionMatrices</span><span class="p">(</span><span class="n">view</span><span class="p">,</span><span class="w"> </span><span class="n">proj</span><span class="p">);</span>
<span class="n">cmd</span><span class="p">.</span><span class="n">SetViewport</span><span class="p">(</span><span class="n">viewport</span><span class="p">);</span>

<span class="n">cmd</span><span class="p">.</span><span class="n">EnableScissorRect</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Rect</span><span class="p">(</span><span class="n">viewport</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="n">viewport</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="m">4</span><span class="p">,</span><span class="w"> </span><span class="n">viewport</span><span class="p">.</span><span class="n">width</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span><span class="n">viewport</span><span class="p">.</span><span class="n">height</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">8</span><span class="p">));</span>
<span class="c1">// 绘制阴影</span>
<span class="n">cmd</span><span class="p">.</span><span class="n">DisableScissorRect</span><span class="p">();</span>
</code></pre></div>
<p>Shadow Caster 的 Shader 直接改 URP 的就行。</p>
<p><img alt="4x4 Per-Object Shadow Map Atlas" src="../../../obsidian-vault/attachments/per-object-shadow-map-atlas.png" /></p>
<p>想支持 SRP Batcher 的话，要用 <a href="https://docs.unity3d.com/ScriptReference/Rendering.ScriptableRenderContext.DrawRenderers.html"><code>ScriptableRenderContext.DrawRenderers</code></a>，但它只能绘制相机里可见的物体。有些物体会投射阴影，但是它不在相机里，所以我目前使用 <a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.DrawRenderer.html"><code>CommandBuffer.DrawRenderer</code></a> 绘制阴影图。</p>
<h3 id="设置-Shader-变量">设置 Shader 变量<a class="headerlink" href="#设置-Shader-变量" title="Permanent link">&para;</a></h3>
<p>因为要设置的变量太多了，就挑几个写写。</p>
<ul>
<li>
<p>Shadow Matrix 的作用是把 World Space Position 变换成 xyzw（正交投影）。xy 是 Shadow Map 的 uv。z 是在光源空间的深度，用来和 Shadow Map 上的值比较。</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span><span class="w"> </span><span class="n">Matrix4x4</span><span class="w"> </span><span class="nf">GetShadowMatrix</span><span class="p">(</span><span class="n">Vector2Int</span><span class="w"> </span><span class="n">tilePos</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">Matrix4x4</span><span class="w"> </span><span class="n">viewMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">Matrix4x4</span><span class="w"> </span><span class="n">projectionMatrix</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">SystemInfo</span><span class="p">.</span><span class="n">usesReversedZBuffer</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m20</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m20</span><span class="p">;</span>
<span class="w">        </span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m21</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m21</span><span class="p">;</span>
<span class="w">        </span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m22</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m22</span><span class="p">;</span>
<span class="w">        </span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m23</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">m23</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">oneOverTileCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m_ShadowMapSizeInTile</span><span class="p">;</span>

<span class="w">    </span><span class="n">Matrix4x4</span><span class="w"> </span><span class="n">textureScaleAndBias</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Matrix4x4</span><span class="p">.</span><span class="n">identity</span><span class="p">;</span>
<span class="w">    </span><span class="n">textureScaleAndBias</span><span class="p">.</span><span class="n">m00</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">oneOverTileCount</span><span class="p">;</span>
<span class="w">    </span><span class="n">textureScaleAndBias</span><span class="p">.</span><span class="n">m11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">oneOverTileCount</span><span class="p">;</span>
<span class="w">    </span><span class="n">textureScaleAndBias</span><span class="p">.</span><span class="n">m22</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5f</span><span class="p">;</span>
<span class="w">    </span><span class="n">textureScaleAndBias</span><span class="p">.</span><span class="n">m03</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">0.5f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tilePos</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">oneOverTileCount</span><span class="p">;</span>
<span class="w">    </span><span class="n">textureScaleAndBias</span><span class="p">.</span><span class="n">m13</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="m">0.5f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tilePos</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">oneOverTileCount</span><span class="p">;</span>
<span class="w">    </span><span class="n">textureScaleAndBias</span><span class="p">.</span><span class="n">m23</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0.5f</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Apply texture scale and offset to save a MAD in shader.</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">textureScaleAndBias</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">projectionMatrix</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">viewMatrix</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>Shadow Map Rect 是图集上某一块 tile 的 uv 范围。</p>
<div class="highlight"><pre><span></span><code><span class="k">private</span><span class="w"> </span><span class="n">Vector4</span><span class="w"> </span><span class="nf">GetShadowMapRect</span><span class="p">(</span><span class="n">Vector2Int</span><span class="w"> </span><span class="n">tilePos</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// x: xMin</span>
<span class="w">    </span><span class="c1">// y: xMax</span>
<span class="w">    </span><span class="c1">// z: yMin</span>
<span class="w">    </span><span class="c1">// w: yMax</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="nf">Vector4</span><span class="p">(</span><span class="n">tilePos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tilePos</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">tilePos</span><span class="p">.</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tilePos</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">m_ShadowMapSizeInTile</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
</li>
</ul>
<h3 id="Shader-代码">Shader 代码<a class="headerlink" href="#Shader-代码" title="Permanent link">&para;</a></h3>
<p>一些工具函数。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float4</span><span class="w"> </span><span class="n">TransformWorldToPerObjectShadowCoord</span><span class="p">(</span><span class="kt">float4x4</span><span class="w"> </span><span class="n">shadowMatrix</span><span class="p">,</span><span class="w"> </span><span class="kt">float3</span><span class="w"> </span><span class="n">positionWS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">mul</span><span class="p">(</span><span class="n">shadowMatrix</span><span class="p">,</span><span class="w"> </span><span class="kt">float4</span><span class="p">(</span><span class="n">positionWS</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">float</span><span class="w"> </span><span class="n">PerObjectShadow</span><span class="p">(</span>
<span class="w">    </span><span class="n">TEXTURE2D_SHADOW_PARAM</span><span class="p">(</span><span class="n">shadowMap</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_shadowMap</span><span class="p">),</span>
<span class="w">    </span><span class="kt">float4</span><span class="w"> </span><span class="n">shadowMapRects</span><span class="p">,</span>
<span class="w">    </span><span class="kt">float4</span><span class="w"> </span><span class="n">shadowCoord</span><span class="p">,</span>
<span class="w">    </span><span class="n">ShadowSamplingData</span><span class="w"> </span><span class="n">shadowSamplingData</span><span class="p">,</span>
<span class="w">    </span><span class="kt">half4</span><span class="w"> </span><span class="n">shadowParams</span><span class="p">,</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">isPerspectiveProjection</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">shadowCoord</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shadowMapRects</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="n">shadowCoord</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shadowMapRects</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="n">shadowCoord</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">shadowMapRects</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">||</span>
<span class="w">        </span><span class="n">shadowCoord</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">shadowMapRects</span><span class="p">.</span><span class="n">w</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// 超出阴影图范围，当作没有阴影</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">SampleShadowmap</span><span class="p">(</span><span class="n">TEXTURE2D_SHADOW_ARGS</span><span class="p">(</span><span class="n">shadowMap</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_shadowMap</span><span class="p">),</span>
<span class="w">            </span><span class="n">shadowCoord</span><span class="p">,</span><span class="w"> </span><span class="n">shadowSamplingData</span><span class="p">,</span><span class="w"> </span><span class="n">shadowParams</span><span class="p">,</span><span class="w"> </span><span class="n">isPerspectiveProjection</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="场景采样角色阴影">场景采样角色阴影<a class="headerlink" href="#场景采样角色阴影" title="Permanent link">&para;</a></h2>
<p>直接遍历一遍，全部采样。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">MainLightPerObjectSceneShadow</span><span class="p">(</span><span class="kt">float3</span><span class="w"> </span><span class="n">positionWS</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ShadowSamplingData</span><span class="w"> </span><span class="n">shadowSamplingData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetMainLightPerObjectSceneShadowSamplingData</span><span class="p">();</span>
<span class="w">    </span><span class="kt">half4</span><span class="w"> </span><span class="n">shadowParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetMainLightShadowParams</span><span class="p">();</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">shadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">_PerObjSceneShadowCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float4</span><span class="w"> </span><span class="n">shadowCoord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TransformWorldToPerObjectShadowCoord</span><span class="p">(</span><span class="n">_PerObjSceneShadowMatrices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">positionWS</span><span class="p">);</span>
<span class="w">        </span><span class="n">shadow</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">min</span><span class="p">(</span><span class="n">shadow</span><span class="p">,</span><span class="w"> </span><span class="n">PerObjectShadow</span><span class="p">(</span><span class="n">TEXTURE2D_SHADOW_ARGS</span><span class="p">(</span><span class="n">_PerObjSceneShadowMap</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_PerObjSceneShadowMap</span><span class="p">),</span>
<span class="w">            </span><span class="n">_PerObjSceneShadowMapRects</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">shadowCoord</span><span class="p">,</span><span class="w"> </span><span class="n">shadowSamplingData</span><span class="p">,</span><span class="w"> </span><span class="n">shadowParams</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">shadow</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="角色自阴影">角色自阴影<a class="headerlink" href="#角色自阴影" title="Permanent link">&para;</a></h2>
<p>角色自阴影比较特殊，如果直接用光源方向绘制阴影图的话，在特殊的光照角度下会出现很丑的阴影和瑕疵。</p>
<p><img alt="常规方案的效果" src="../../../obsidian-vault/attachments/Pasted%20image%2020240714171505.png" /></p>
<p>我观察了游戏里自阴影的效果，发现他们使用了视角和光源的混合方向绘制阴影图。我模仿他们设计了下面这个算法</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 混合视角和主光源的方向，视角方向不用 camera forward，避免转动视角时阴影方向变化</span>
<span class="c1">// 直接用向量插值，四元数插值会导致部分情况跳变</span>
<span class="c1">// 以视角方向为主，减少背面 artifact</span>
<span class="n">float3</span><span class="w"> </span><span class="n">viewForward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalizesafe</span><span class="p">(</span><span class="n">aabbCenter</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cameraPosition</span><span class="p">);</span>
<span class="n">float3</span><span class="w"> </span><span class="n">forward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">lerp</span><span class="p">(</span><span class="n">viewForward</span><span class="p">,</span><span class="w"> </span><span class="n">lightForward</span><span class="p">,</span><span class="w"> </span><span class="m">0.2f</span><span class="p">));</span>

<span class="c1">// 超低角度观察会出现不该有的阴影</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cosAngle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dot</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">CasterUpVector</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cosAngleClamped</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clamp</span><span class="p">(</span><span class="n">cosAngle</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="m">0.866f</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// 限制在 90° ~ 150° 之间</span>
<span class="n">forward</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">normalize</span><span class="p">(</span><span class="n">forward</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">cosAngleClamped</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cosAngle</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">args</span><span class="p">.</span><span class="n">CasterUpVector</span><span class="p">);</span>

<span class="n">lightRotation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">quaternion</span><span class="p">.</span><span class="n">LookRotation</span><span class="p">(</span><span class="n">forward</span><span class="p">,</span><span class="w"> </span><span class="n">cameraUp</span><span class="p">);</span>
<span class="n">lightDirection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">float4</span><span class="p">(</span><span class="o">-</span><span class="n">forward</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">);</span>
</code></pre></div>
<p>同样的视角和光照角度，效果比刚才好多了。</p>
<p><img alt="星穹铁道方案的效果" src="../../../obsidian-vault/attachments/Pasted%20image%2020240714171941.png" /></p>
<p>采样的时候需要一个 <code>casterId</code>，场景里每个角色实例的 <code>casterId</code> 是唯一且不变的，由 C# 代码设置到角色的材质上。</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">MainLightPerObjectSelfShadow</span><span class="p">(</span><span class="kt">float3</span><span class="w"> </span><span class="n">positionWS</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">casterId</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">ShadowSamplingData</span><span class="w"> </span><span class="n">shadowSamplingData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetMainLightPerObjectSelfShadowSamplingData</span><span class="p">();</span>
<span class="w">    </span><span class="kt">half4</span><span class="w"> </span><span class="n">shadowParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetMainLightShadowParams</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mo">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">_PerObjSelfShadowCount</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">_PerObjSelfShadowCasterIds</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">casterId</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mf">0.001</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">float4</span><span class="w"> </span><span class="n">shadowCoord</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TransformWorldToPerObjectShadowCoord</span><span class="p">(</span><span class="n">_PerObjSelfShadowMatrices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">positionWS</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">PerObjectShadow</span><span class="p">(</span><span class="n">TEXTURE2D_SHADOW_ARGS</span><span class="p">(</span><span class="n">_PerObjSelfShadowMap</span><span class="p">,</span><span class="w"> </span><span class="n">sampler_PerObjSelfShadowMap</span><span class="p">),</span>
<span class="w">            </span><span class="n">_PerObjSelfShadowMapRects</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">shadowCoord</span><span class="p">,</span><span class="w"> </span><span class="n">shadowSamplingData</span><span class="p">,</span><span class="w"> </span><span class="n">shadowParams</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>你可能会好奇，为什么不直接传一个 <code>shadowIndex</code>，这样 Shader 里不是能少一个循环吗？</p>
<pre class="mermaid"><code>sequenceDiagram
    participant CPU
    actor 角色材质
    participant GPU

    CPU-&gt;&gt;角色材质: 设置 shadowIndex
    CPU-&gt;&gt;+GPU: 提交数据，请求绘制
    GPU-&gt;&gt;-角色材质: 读取并绘制角色
    CPU-&gt;&gt;角色材质: 设置 shadowIndex
    CPU-&gt;&gt;+GPU: 提交数据，请求绘制
    CPU-&gt;&gt;角色材质: 设置 shadowIndex
    GPU-&gt;&gt;-角色材质: 读取并绘制角色
    CPU-&gt;&gt;+GPU: 提交数据，请求绘制
    GPU-&gt;&gt;-角色材质: 读取并绘制角色</code></pre>
<blockquote>
<p>图中的「提交数据」指通过 <a href="https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.SetGlobalMatrixArray.html"><code>CommandBuffer.SetGlobalMatrixArray</code></a> 这类 API 设置的数据，GPU 执行到这里才会生效。但角色材质数据是在 cbuffer 里的，CPU 一旦设置就立即生效。</p>
</blockquote>
<p>考虑上图的情况，第二次绘制时，GPU 读取的是下一帧的 <code>shadowIndex</code>，导致阴影渲染出错。从视觉效果上讲，就是阴影突然消失，之后可能又突然出现。URP 是 SceneView、Preview、Game 等多个 Camera 交替渲染的，每个 Camera 都要设置自己的 <code>shadowIndex</code>，但角色材质只有一份，竞争更加激烈，阴影更容易出错。而 <code>casterId</code> 的值在第一次设置后就不变了，能解决上面的问题，代价是在 Shader 里加了个循环。</p>
<p>游戏里头发是不采样自阴影的。脸部使用的是基于深度偏移的刘海阴影，具体讲就是，提前画一张只有头发的深度图，绘制脸部时，根据光照方向偏移采样这张深度图，然后确定阴影区域，流程和深度偏移的边缘光比较像。这样不容易把脸弄脏，开销少一点，阴影图的大小也能适当减小一点。</p>
<h2 id="完整代码">完整代码<a class="headerlink" href="#完整代码" title="Permanent link">&para;</a></h2>
<p><a href="https://github.com/stalomeow/StarRailNPRShader">GitHub: stalomeow/StarRailNPRShader</a></p>
<h2 id="参考文章">参考文章<a class="headerlink" href="#参考文章" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/667305414">图形引擎实战：自阴影渲染分享 - 知乎</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/666545782">Unity 从DecalSystem创建PerObjectShadow - 知乎</a></li>
</ul>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://docs.unity3d.com/ScriptReference/Matrix4x4.Ortho.html">Unity - Scripting API: Matrix4x4.Ortho</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
</ol>
</div><hr />