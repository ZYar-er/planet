<h1 id="实现-IJobParallelForAppend">实现 IJobParallelForAppend<a class="headerlink" href="#实现-IJobParallelForAppend" title="Permanent link">&para;</a></h1>
<!-- more -->

<p>Unity 的 <a href="https://docs.unity3d.com/Packages/com.unity.collections@2.4/manual/index.html">Collections package</a> 里有个 <a href="https://docs.unity3d.com/Packages/com.unity.collections@2.4/api/Unity.Jobs.IJobParallelForFilter.html"><code>IJobParallelForFilter</code></a>。我翻了相关的源码，发现虽然它名字带个 Parallel，但根本不是并行的。它的全部逻辑都是在一个线程里做的。后来，Unity 就把它名字里的 Parallel 去掉了，改成 <a href="https://docs.unity3d.com/Packages/com.unity.collections@2.4/api/Unity.Jobs.IJobFilter.html"><code>IJobFilter</code></a>。理由是</p>
<blockquote>
<p><code>IJobParallelForFilter</code> renamed to <code>IJobFilter</code> to better reflect functionality. <sup id="fnref:1"><a class="footnote-ref" href="#fn:1">1</a></sup></p>
</blockquote>
<p>我有并行的需求，自己实现了一个超级加强版。</p>
<div class="highlight"><pre><span></span><code><span class="na">[JobProducerType(typeof(IJobParallelForAppendExtensions.ParallelForAppendProducer&lt;,&gt;))]</span>
<span class="k">public</span><span class="w"> </span><span class="k">interface</span><span class="w"> </span><span class="n">IJobParallelForAppend</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TValue</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">unmanaged</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Execute</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">TValue</span><span class="w"> </span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>它可以并行 Append 任意的 unmanaged 数据，不再局限于 <code>index</code>。有点像 Compute Shader 那套东西。</p>
<ul>
<li><code>index</code> 是 for 循环当前的索引。</li>
<li><code>buf</code> 是一个临时缓冲区。</li>
</ul>
<p>如果 <code>Execute</code> 返回 <code>true</code>，<code>buf</code> 的值会被 Append 到结果里。</p>
<h2 id="样例">样例<a class="headerlink" href="#样例" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="na">[BurstCompile]</span>
<span class="k">public</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">TestJob</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">IJobParallelForAppend</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="nf">Execute</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">index</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">buf</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">index</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="m">2</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">JobTest</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">MonoBehaviour</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Start</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">using</span><span class="w"> </span><span class="nn">var</span><span class="w"> </span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">NativeList</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Allocator</span><span class="p">.</span><span class="n">TempJob</span><span class="p">);</span>
<span class="w">        </span><span class="n">TestJob</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">TestJob</span><span class="p">();</span>
<span class="w">        </span><span class="n">job</span><span class="p">.</span><span class="n">Schedule</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="m">12</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">).</span><span class="n">Complete</span><span class="p">();</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">print</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>输出是 0，4，8，12，16，20，但顺序不固定。</p>
<h2 id="核心代码">核心代码<a class="headerlink" href="#核心代码" title="Permanent link">&para;</a></h2>
<p><code>ParallelForAppendProducer&lt;TJob, TValue&gt;.Execute</code> 是核心的方法。在 Schedule 前分配好 <code>NativeList&lt;TValue&gt;</code> 的空间，每次有数据要 Append 时，用 <code>Interlocked.Increment</code> 增加 List 的元素数量，把值存进去就好。</p>
<div class="highlight"><pre><span></span><code><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">IJobParallelForAppendExtensions</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">internal</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TValue</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">unmanaged</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">struct</span><span class="p">,</span><span class="w"> </span><span class="n">IJobParallelForAppend</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">JobWrapper</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="na">[NativeDisableUnsafePtrRestriction]</span>
<span class="w">            </span><span class="k">public</span><span class="w"> </span><span class="n">UnsafeList</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;*</span><span class="w"> </span><span class="n">AppendBuffer</span><span class="p">;</span>
<span class="w">            </span><span class="k">public</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="n">JobData</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">internal</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">readonly</span><span class="w"> </span><span class="n">SharedStatic</span><span class="o">&lt;</span><span class="n">IntPtr</span><span class="o">&gt;</span><span class="w"> </span><span class="n">jobReflectionData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SharedStatic</span><span class="o">&lt;</span><span class="n">IntPtr</span><span class="o">&gt;</span><span class="p">.</span><span class="n">GetOrCreate</span><span class="o">&lt;</span><span class="n">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;&gt;</span><span class="p">();</span>

<span class="w">        </span><span class="na">[BurstDiscard]</span>
<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Initialize</span><span class="p">()</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">jobReflectionData</span><span class="p">.</span><span class="n">Data</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">IntPtr</span><span class="p">.</span><span class="n">Zero</span><span class="p">)</span>
<span class="w">                </span><span class="n">jobReflectionData</span><span class="p">.</span><span class="n">Data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">CreateJobReflectionData</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">JobWrapper</span><span class="p">),</span><span class="w"> </span><span class="k">typeof</span><span class="p">(</span><span class="n">TJob</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="n">ExecuteJobFunction</span><span class="p">)</span><span class="n">Execute</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">delegate</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">ExecuteJobFunction</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">JobWrapper</span><span class="w"> </span><span class="n">jobWrapper</span><span class="p">,</span><span class="w"> </span><span class="n">IntPtr</span><span class="w"> </span><span class="n">additionalPtr</span><span class="p">,</span><span class="w"> </span><span class="n">IntPtr</span><span class="w"> </span><span class="n">bufferRangePatchData</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">JobRanges</span><span class="w"> </span><span class="n">ranges</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">jobIndex</span><span class="p">);</span>

<span class="w">        </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">Execute</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">JobWrapper</span><span class="w"> </span><span class="n">jobWrapper</span><span class="p">,</span><span class="w"> </span><span class="n">IntPtr</span><span class="w"> </span><span class="n">additionalPtr</span><span class="p">,</span><span class="w"> </span><span class="n">IntPtr</span><span class="w"> </span><span class="n">bufferRangePatchData</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">JobRanges</span><span class="w"> </span><span class="n">ranges</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">jobIndex</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">TValue</span><span class="w"> </span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">default</span><span class="p">;</span>

<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">GetWorkStealingRange</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">ranges</span><span class="p">,</span><span class="w"> </span><span class="n">jobIndex</span><span class="p">,</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">end</span><span class="p">))</span>
<span class="w">                    </span><span class="k">break</span><span class="p">;</span>

<span class="w">                </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">PatchBufferMinMaxRanges</span><span class="p">(</span><span class="n">bufferRangePatchData</span><span class="p">,</span><span class="w"> </span><span class="n">UnsafeUtility</span><span class="p">.</span><span class="n">AddressOf</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">jobWrapper</span><span class="p">),</span><span class="w"> </span><span class="n">begin</span><span class="p">,</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">begin</span><span class="p">);</span>

<span class="w">                </span><span class="kt">var</span><span class="w"> </span><span class="n">endThatCompilerCanSeeWillNeverChange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">end</span><span class="p">;</span>
<span class="w">                </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">begin</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">endThatCompilerCanSeeWillNeverChange</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">jobWrapper</span><span class="p">.</span><span class="n">JobData</span><span class="p">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="k">ref</span><span class="w"> </span><span class="n">buf</span><span class="p">))</span>
<span class="w">                    </span><span class="p">{</span>
<span class="w">                        </span><span class="kt">int</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Interlocked</span><span class="p">.</span><span class="n">Increment</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">jobWrapper</span><span class="p">.</span><span class="n">AppendBuffer</span><span class="o">-&gt;</span><span class="n">m_length</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="w">                        </span><span class="n">jobWrapper</span><span class="p">.</span><span class="n">AppendBuffer</span><span class="o">-&gt;</span><span class="n">Ptr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buf</span><span class="p">;</span>
<span class="w">                    </span><span class="p">}</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">EarlyJobInit</span><span class="o">&lt;</span><span class="n">TJob</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="k">struct</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="n">Type</span><span class="w"> </span><span class="n">iType</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="k">typeof</span><span class="p">(</span><span class="n">TJob</span><span class="p">).</span><span class="n">GetInterfaces</span><span class="p">())</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iType</span><span class="p">.</span><span class="n">IsGenericType</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">iType</span><span class="p">.</span><span class="n">GetGenericTypeDefinition</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="k">typeof</span><span class="p">(</span><span class="n">IJobParallelForAppend</span><span class="o">&lt;&gt;</span><span class="p">))</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">Type</span><span class="p">[]</span><span class="w"> </span><span class="n">genericArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iType</span><span class="p">.</span><span class="n">GetGenericArguments</span><span class="p">();</span>
<span class="w">                </span><span class="n">Type</span><span class="p">[]</span><span class="w"> </span><span class="n">typeArgs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Type</span><span class="p">[</span><span class="m">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">genericArgs</span><span class="p">.</span><span class="n">Length</span><span class="p">];</span>
<span class="w">                </span><span class="n">typeArgs</span><span class="p">[</span><span class="m">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typeof</span><span class="p">(</span><span class="n">TJob</span><span class="p">);</span>
<span class="w">                </span><span class="n">Array</span><span class="p">.</span><span class="n">Copy</span><span class="p">(</span><span class="n">genericArgs</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">typeArgs</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">genericArgs</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>

<span class="w">                </span><span class="n">Type</span><span class="w"> </span><span class="n">producerType</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">typeof</span><span class="p">(</span><span class="n">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="p">,</span><span class="o">&gt;</span><span class="p">).</span><span class="n">MakeGenericType</span><span class="p">(</span><span class="n">typeArgs</span><span class="p">);</span>
<span class="w">                </span><span class="n">producerType</span><span class="p">.</span><span class="n">GetMethod</span><span class="p">(</span><span class="s">&quot;Initialize&quot;</span><span class="p">).</span><span class="n">Invoke</span><span class="p">(</span><span class="k">null</span><span class="p">,</span><span class="w"> </span><span class="k">null</span><span class="p">);</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">private</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="n">IntPtr</span><span class="w"> </span><span class="n">GetReflectionData</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">()</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TValue</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">unmanaged</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">struct</span><span class="p">,</span><span class="w"> </span><span class="n">IJobParallelForAppend</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">.</span><span class="n">Initialize</span><span class="p">();</span>
<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">reflectionData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">.</span><span class="n">jobReflectionData</span><span class="p">.</span><span class="n">Data</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// JobValidationInternal.CheckReflectionDataCorrect&lt;T&gt;(reflectionData);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">reflectionData</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="n">JobHandle</span><span class="w"> </span><span class="n">Schedule</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="n">jobData</span><span class="p">,</span><span class="w"> </span><span class="n">NativeList</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">innerloopBatchCount</span><span class="p">,</span><span class="w"> </span><span class="n">JobHandle</span><span class="w"> </span><span class="n">dependsOn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobHandle</span><span class="p">())</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TValue</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">unmanaged</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">struct</span><span class="p">,</span><span class="w"> </span><span class="n">IJobParallelForAppend</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">Capacity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">buffer</span><span class="p">.</span><span class="n">SetCapacity</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">jobWrapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">.</span><span class="n">JobWrapper</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">AppendBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">GetUnsafeList</span><span class="p">(),</span>
<span class="w">            </span><span class="n">JobData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jobData</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">scheduleParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">JobScheduleParameters</span><span class="p">(</span><span class="n">UnsafeUtility</span><span class="p">.</span><span class="n">AddressOf</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">jobWrapper</span><span class="p">),</span><span class="w"> </span><span class="n">GetReflectionData</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">dependsOn</span><span class="p">,</span><span class="w"> </span><span class="n">ScheduleMode</span><span class="p">.</span><span class="n">Parallel</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">ScheduleParallelFor</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">scheduleParams</span><span class="p">,</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">,</span><span class="w"> </span><span class="n">innerloopBatchCount</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">Run</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="n">jobData</span><span class="p">,</span><span class="w"> </span><span class="n">NativeList</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TValue</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">unmanaged</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">struct</span><span class="p">,</span><span class="w"> </span><span class="n">IJobParallelForAppend</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">Capacity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">buffer</span><span class="p">.</span><span class="n">SetCapacity</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">jobWrapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">.</span><span class="n">JobWrapper</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">AppendBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">GetUnsafeList</span><span class="p">(),</span>
<span class="w">            </span><span class="n">JobData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jobData</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">scheduleParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">JobScheduleParameters</span><span class="p">(</span><span class="n">UnsafeUtility</span><span class="p">.</span><span class="n">AddressOf</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">jobWrapper</span><span class="p">),</span><span class="w"> </span><span class="n">GetReflectionData</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobHandle</span><span class="p">(),</span><span class="w"> </span><span class="n">ScheduleMode</span><span class="p">.</span><span class="n">Run</span><span class="p">);</span>
<span class="w">        </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">ScheduleParallelFor</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">scheduleParams</span><span class="p">,</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">,</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="n">JobHandle</span><span class="w"> </span><span class="n">ScheduleByRef</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">this</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="n">jobData</span><span class="p">,</span><span class="w"> </span><span class="n">NativeList</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">innerloopBatchCount</span><span class="p">,</span><span class="w"> </span><span class="n">JobHandle</span><span class="w"> </span><span class="n">dependsOn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobHandle</span><span class="p">())</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TValue</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">unmanaged</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">struct</span><span class="p">,</span><span class="w"> </span><span class="n">IJobParallelForAppend</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">Capacity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">buffer</span><span class="p">.</span><span class="n">SetCapacity</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">jobWrapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">.</span><span class="n">JobWrapper</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">AppendBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">GetUnsafeList</span><span class="p">(),</span>
<span class="w">            </span><span class="n">JobData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jobData</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">scheduleParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">JobScheduleParameters</span><span class="p">(</span><span class="n">UnsafeUtility</span><span class="p">.</span><span class="n">AddressOf</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">jobWrapper</span><span class="p">),</span><span class="w"> </span><span class="n">GetReflectionData</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="n">dependsOn</span><span class="p">,</span><span class="w"> </span><span class="n">ScheduleMode</span><span class="p">.</span><span class="n">Parallel</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">ScheduleParallelFor</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">scheduleParams</span><span class="p">,</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">,</span><span class="w"> </span><span class="n">innerloopBatchCount</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">unsafe</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="n">RunByRef</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="k">this</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="n">jobData</span><span class="p">,</span><span class="w"> </span><span class="n">NativeList</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">)</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TValue</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">unmanaged</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">TJob</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">struct</span><span class="p">,</span><span class="w"> </span><span class="n">IJobParallelForAppend</span><span class="o">&lt;</span><span class="n">TValue</span><span class="o">&gt;</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">Capacity</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">buffer</span><span class="p">.</span><span class="n">SetCapacity</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="n">Length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">jobWrapper</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ParallelForAppendProducer</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">.</span><span class="n">JobWrapper</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">AppendBuffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">buffer</span><span class="p">.</span><span class="n">GetUnsafeList</span><span class="p">(),</span>
<span class="w">            </span><span class="n">JobData</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">jobData</span>
<span class="w">        </span><span class="p">};</span>

<span class="w">        </span><span class="kt">var</span><span class="w"> </span><span class="n">scheduleParams</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">JobScheduleParameters</span><span class="p">(</span><span class="n">UnsafeUtility</span><span class="p">.</span><span class="n">AddressOf</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">jobWrapper</span><span class="p">),</span><span class="w"> </span><span class="n">GetReflectionData</span><span class="o">&lt;</span><span class="n">TJob</span><span class="p">,</span><span class="w"> </span><span class="n">TValue</span><span class="o">&gt;</span><span class="p">(),</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobHandle</span><span class="p">(),</span><span class="w"> </span><span class="n">ScheduleMode</span><span class="p">.</span><span class="n">Run</span><span class="p">);</span>
<span class="w">        </span><span class="n">JobsUtility</span><span class="p">.</span><span class="n">ScheduleParallelFor</span><span class="p">(</span><span class="k">ref</span><span class="w"> </span><span class="n">scheduleParams</span><span class="p">,</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">,</span><span class="w"> </span><span class="n">arrayLength</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h2 id="避坑指南">避坑指南<a class="headerlink" href="#避坑指南" title="Permanent link">&para;</a></h2>
<p>写泛型 Job 接口有不少坑。</p>
<h3 id="JobProducer-类型参数顺序">JobProducer 类型参数顺序<a class="headerlink" href="#JobProducer-类型参数顺序" title="Permanent link">&para;</a></h3>
<p>泛型 Job 接口，对应的 JobProducer 的类型参数顺序必须是</p>
<ol>
<li><code>TJob</code>：具体的 Job 类型。</li>
<li><code>...T</code>：<code>TJob</code> 实现的 Job 接口的类型参数。</li>
</ol>
<p>否则不兼容 Burst Compiler。这个在 Burst 源码 <code>Runtime/Editor/BurstReflection.cs</code> 里的 <code>ScanJobType</code> 方法里写死了。</p>
<p>比如 <code>IJobParallelForAppend&lt;TValue&gt;</code> 对应 <code>ParallelForAppendProducer&lt;TJob, TValue&gt;</code>。</p>
<h3 id="EarlyJobInit-类型参数数量">EarlyJobInit 类型参数数量<a class="headerlink" href="#EarlyJobInit-类型参数数量" title="Permanent link">&para;</a></h3>
<p>这个太坑了。</p>
<blockquote>
<p>When the Collections package is included in the project, Unity generates code to call EarlyJobInit at startup. This allows Burst compiled code to schedule jobs because the reflection part of initialization, which is not compatible with burst compiler constraints, has already happened in EarlyJobInit. <sup id="fnref:2"><a class="footnote-ref" href="#fn:2">2</a></sup></p>
</blockquote>
<p>生成的代码：</p>
<div class="highlight"><pre><span></span><code><span class="na">[Unity.Jobs.DOTSCompilerGenerated]</span>
<span class="k">internal</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="nc">__JobReflectionRegistrationOutput__2275960884</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">CreateJobReflectionData</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">try</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">IJobParallelForAppendExtensions</span><span class="p">.</span><span class="n">EarlyJobInit</span><span class="o">&lt;</span><span class="n">TestJob</span><span class="o">&gt;</span><span class="p">();</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">ex</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">EarlyInitHelpers</span><span class="p">.</span><span class="n">JobReflectionDataCreationFailed</span><span class="p">(</span><span class="n">ex</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="na">[InitializeOnLoadMethod]</span>
<span class="w">    </span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="k">void</span><span class="w"> </span><span class="nf">EarlyInit</span><span class="p">()</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">CreateJobReflectionData</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>它调用 <code>EarlyJobInit</code> 时只给了一个 <code>TJob</code> 类型参数。如果我们声明的是 <code>EarlyJobInit&lt;TJob, TValue&gt;</code> 就会报错。这个在 Collections 源码 <code>Unity.Collections.CodeGen/JobReflectionDataPostProcessor.cs</code> 的 <code>GenerateCalls</code> 方法里写死了。。。</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p><a href="https://docs.unity3d.com/Packages/com.unity.collections@2.4/changelog/CHANGELOG.html#changed-10">https://docs.unity3d.com/Packages/com.unity.collections@2.4/changelog/CHANGELOG.html#changed-10</a>&#160;<a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p><a href="https://docs.unity3d.com/Packages/com.unity.collections@2.4/api/Unity.Jobs.IJobFilterExtensions.html">https://docs.unity3d.com/Packages/com.unity.collections@2.4/api/Unity.Jobs.IJobFilterExtensions.html</a>&#160;<a class="footnote-backref" href="#fnref:2" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div><hr />