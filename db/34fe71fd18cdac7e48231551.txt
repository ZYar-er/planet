<blockquote><h1 id="深度重建世界坐标">深度重建世界坐标<a class="headerlink" href="#深度重建世界坐标" title="Permanent link">&para;</a></h1>
<!-- more -->

<p>在后处理 Shader 还有一些屏幕空间效果中，常需要使用深度还原世界坐标。</p>
<h2 id="逆矩阵法">逆矩阵法<a class="headerlink" href="#逆矩阵法" title="Permanent link">&para;</a></h2>
<h3 id="推导">推导<a class="headerlink" href="#推导" title="Permanent link">&para;</a></h3>
<p>根据 uv 和 depth 可以还原出 <code>positionNDC.xyz</code>。由</p>
<div class="highlight"><pre><span></span><code><span class="n">positionCS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mul</span><span class="p">(</span><span class="n">MatrixVP</span><span class="p">,</span><span class="w"> </span><span class="n">positionWS</span><span class="p">);</span>
<span class="n">positionNDC</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positionCS</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">positionCS</span><span class="p">.</span><span class="n">w</span><span class="p">;</span><span class="w"> </span><span class="c1">// positionNDC.w 一定为 1</span>
</code></pre></div>
<p>可得</p>
<div class="highlight"><pre><span></span><code><span class="n">positionWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mul</span><span class="p">(</span><span class="n">MatrixInvVP</span><span class="p">,</span><span class="w"> </span><span class="n">positionCS</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">positionNDC</span><span class="p">);</span>
</code></pre></div>
<p><code>w</code> 分量的公式为</p>
<div class="highlight"><pre><span></span><code><span class="n">positionWS</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">dot</span><span class="p">(</span><span class="n">MatrixInvVP</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">positionCS</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">positionNDC</span><span class="p">);</span>
</code></pre></div>
<p>因为 <code>positionWS.w == 1</code> 所以</p>
<div class="highlight"><pre><span></span><code><span class="n">positionCS</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">dot</span><span class="p">(</span><span class="n">MatrixInvVP</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">positionNDC</span><span class="p">);</span>
</code></pre></div>
<p>带回去得到</p>
<div class="highlight"><pre><span></span><code><span class="n">positionWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mul</span><span class="p">(</span><span class="n">MatrixInvVP</span><span class="p">,</span><span class="w"> </span><span class="n">positionNDC</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">dot</span><span class="p">(</span><span class="n">MatrixInvVP</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="n">positionNDC</span><span class="p">);</span>
</code></pre></div>
<p>化简得到</p>
<div class="highlight"><pre><span></span><code><span class="n">positionWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mul</span><span class="p">(</span><span class="n">MatrixInvVP</span><span class="p">,</span><span class="w"> </span><span class="n">positionNDC</span><span class="p">);</span>
<span class="n">positionWS</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">positionWS</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
</code></pre></div>
<h3 id="URP-实现">URP 实现<a class="headerlink" href="#URP-实现" title="Permanent link">&para;</a></h3>
<p>在 <code>Packages/com.unity.render-pipelines.universal/ShaderLibrary/Common.hlsl</code> 里有相关的实现。</p>
<blockquote>
<p>注意此处 URP 的 <code>positionNDC.xy</code> 是屏幕 <code>uv</code>，范围是 <code>[0, 1]</code>，与前面推导时用的 <code>positionNDC</code> 的定义不同。</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">float4</span><span class="w"> </span><span class="n">ComputeClipSpacePosition</span><span class="p">(</span><span class="kt">float2</span><span class="w"> </span><span class="n">positionNDC</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">deviceDepth</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float4</span><span class="w"> </span><span class="n">positionCS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float4</span><span class="p">(</span><span class="n">positionNDC</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">deviceDepth</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>

<span class="cp">#if UNITY_UV_STARTS_AT_TOP</span>
<span class="w">    </span><span class="c1">// Our world space, view space, screen space and NDC space are Y-up.</span>
<span class="w">    </span><span class="c1">// Our clip space is flipped upside-down due to poor legacy Unity design.</span>
<span class="w">    </span><span class="c1">// The flip is baked into the projection matrix, so we only have to flip</span>
<span class="w">    </span><span class="c1">// manually when going from CS to NDC and back.</span>
<span class="w">    </span><span class="n">positionCS</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">positionCS</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">positionCS</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">float3</span><span class="w"> </span><span class="n">ComputeWorldSpacePosition</span><span class="p">(</span><span class="kt">float2</span><span class="w"> </span><span class="n">positionNDC</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">deviceDepth</span><span class="p">,</span><span class="w"> </span><span class="kt">float4x4</span><span class="w"> </span><span class="n">invViewProjMatrix</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 这个 positionCS 才是前面推导时的 positionNDC</span>
<span class="w">    </span><span class="kt">float4</span><span class="w"> </span><span class="n">positionCS</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeClipSpacePosition</span><span class="p">(</span><span class="n">positionNDC</span><span class="p">,</span><span class="w"> </span><span class="n">deviceDepth</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float4</span><span class="w"> </span><span class="n">hpositionWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">mul</span><span class="p">(</span><span class="n">invViewProjMatrix</span><span class="p">,</span><span class="w"> </span><span class="n">positionCS</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">hpositionWS</span><span class="p">.</span><span class="n">xyz</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hpositionWS</span><span class="p">.</span><span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>使用方法</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span>
<span class="cp">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;</span>

<span class="c1">// ...</span>

<span class="kt">float</span><span class="w"> </span><span class="n">deviceDepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SampleSceneDepth</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">.</span><span class="n">xy</span><span class="p">);</span>

<span class="cp">#if !UNITY_REVERSED_Z</span>
<span class="w">    </span><span class="n">deviceDepth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">deviceDepth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">2.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="kt">float3</span><span class="w"> </span><span class="n">positionWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeWorldSpacePosition</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">.</span><span class="n">xy</span><span class="p">,</span><span class="w"> </span><span class="n">deviceDepth</span><span class="p">,</span><span class="w"> </span><span class="n">unity_MatrixInvVP</span><span class="p">);</span>
</code></pre></div>
<h2 id="相似三角形法">相似三角形法<a class="headerlink" href="#相似三角形法" title="Permanent link">&para;</a></h2>
<p>这个方法来自 SIGGRAPH 2011 中的 Secrets of CryENGINE 3  Graphics Technology。</p>
<h3 id="推导_1">推导<a class="headerlink" href="#推导_1" title="Permanent link">&para;</a></h3>
<p><img alt="原理图（原图来自 Secrets of CryENGINE 3  Graphics Technology 的 ppt）" src="../../../obsidian-vault/attachments/Pasted%20image%2020240711142202.png" /></p>
<p>假设要重建点 C 的世界坐标。由</p>
<div class="arithmatex">\[
\triangle \text{ABC} \sim \triangle \text{ADE}
\]</div>
<p>得到</p>
<div class="arithmatex">\[
\dfrac{\left | \text{AB} \right |}{\left | \text{AD} \right |} = \dfrac{\left | \text{AC} \right |}{\left | \text{AE} \right |}
\]</div>
<p>如果深度是在 Linear01 空间的话，<span class="arithmatex">\(\left | \text{AD} \right | =1\)</span>，<span class="arithmatex">\(\left | \text{AB} \right |\)</span> 就是点 C 的 Linear01Depth，所以</p>
<div class="arithmatex">\[
\overrightarrow{\text{AC}} = \left | \text{AB} \right | \overrightarrow{\text{AE}}
\]</div>
<p>等号两边同时变换到世界空间</p>
<div class="arithmatex">\[
\overrightarrow{\text{AC}}_\text{ws} = \left | \text{AB} \right | \overrightarrow{\text{AE}}_\text{ws}
\]</div>
<p>再加上点 A（相机）的世界坐标就能算出点 C 的世界坐标。</p>
<h3 id="URP-实现_1">URP 实现<a class="headerlink" href="#URP-实现_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include &quot;Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl&quot;</span>
<span class="cp">#include &quot;Packages/com.unity.render-pipelines.universal/ShaderLibrary/DeclareDepthTexture.hlsl&quot;</span>
</code></pre></div>
<p>先在 Vertex Shader 里计算 <span class="arithmatex">\(\overrightarrow{\text{AE}}_\text{ws}\)</span></p>
<div class="highlight"><pre><span></span><code><span class="c1">// 在 Blit Shader 中 texcoord 需要使用 API 计算出来，参考 Packages/com.unity.render-pipelines.core/Runtime/Utilities/Blit.hlsl</span>
<span class="kt">float3</span><span class="w"> </span><span class="n">positionWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeWorldSpacePosition</span><span class="p">(</span><span class="n">texcoord</span><span class="p">,</span><span class="w"> </span><span class="n">UNITY_RAW_FAR_CLIP_VALUE</span><span class="p">,</span><span class="w"> </span><span class="n">unity_MatrixInvVP</span><span class="p">);</span>
<span class="n">output</span><span class="p">.</span><span class="n">viewRayWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">positionWS</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">GetCameraPositionWS</span><span class="p">();</span>
</code></pre></div>
<p>在 Fragment Shader 里，还原世界坐标</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Linear01Depth</span><span class="p">(</span><span class="n">SampleSceneDepth</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">texcoord</span><span class="p">.</span><span class="n">xy</span><span class="p">),</span><span class="w"> </span><span class="n">_ZBufferParams</span><span class="p">);</span>
<span class="kt">float3</span><span class="w"> </span><span class="n">positionWS</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">depth</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">input</span><span class="p">.</span><span class="n">viewRayWS</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">GetCameraPositionWS</span><span class="p">();</span>
</code></pre></div>
<p>这个方法的矩阵运算在 Vertex Shader 里进行，计算量小一点，但是 URP 的 Blit Vertex Shader 改起来相对麻烦一点。第一种方法只需要改 Fragment Shader 就行了，更好写。</p>
<h2 id="参考资料">参考资料<a class="headerlink" href="#参考资料" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://blog.csdn.net/yinfourever/article/details/120935179">Unity URP中根据深度重建世界坐标_computeworldspaceposition-CSDN博客</a></li>
<li><a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@14.0/manual/writing-shaders-urp-reconstruct-world-position.html">Reconstruct the world space positions of pixels from the depth texture | Universal RP | 14.0.11 (unity3d.com)</a></li>
</ul></blockquote>